<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            background-color: white;
        }

        .mask_canvas {
            position: absolute;
            top: -50000px;
            left: -50000px;
        }

        .next_canvas {
            position: absolute;
            top: -100000px;
            left: -100000px;
        }
    </style>
</head>
<body style="background-color: #000;text-align: center;padding:0 0 0 0; margin: 0 0 0 0">
<canvas id="canvas" width="800" height="600"></canvas>
<canvas id="mask" class="mask_canvas" width="800" height="600"></canvas>
<canvas id="next" class="next_canvas" width="800" height="600"></canvas>
<br>
<button id="step1">上一步</button>
<button id="step2">下一步</button>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
<script src="main.js"></script>
<script>
    $(function () {
        var canvas = $('#canvas')[0];

        var presentationData = {};

        var canvasData = {};

        var slideList = [];

        var currentSlide = 0;

        var media = {};

        var langmap = {
            "zh-TW": "ea",
            "zh-CN": "ea",
            "en-US": "latin",
            "en-GB": "latin"
        };

        var scriptmap = {
            "zh-TW": 'Hant',
            "zh-CN": 'Hans'
        };
        var fontmap = {};

        presentationInit(data);

        $('#step1').click(function() {
            if(currentSlide > 0) {
                currentSlide--;
                slideInit(data, currentSlide);
            }
        });
        $('#step2').click(function() {
            if(currentSlide < slideList.length-1) {
                currentSlide++;
                slideInit(data, currentSlide);
            }
        });

        $(document).on('keyup', function(e) {
            if(e.keyCode === 39 || e.keyCode === 32) {
                if(currentSlide < slideList.length-1) {
                    currentSlide++;
                    slideInit(data, currentSlide);
                }
            }
            if(e.keyCode === 37) {
                if(currentSlide > 0) {
                    currentSlide--;
                    slideInit(data, currentSlide);
                }
            }
        });

        function canvasInit() {
            var vzw = document.documentElement.clientWidth;
            var vzh = document.documentElement.clientHeight;
            var _canvasd = calculateCanvasWidth(vzw, vzh);
            var canvas = $('#canvas')[0];
            var mask = $('#mask')[0];
            var next = $('#next')[0];

            canvasData.cw = _canvasd.w;
            canvasData.ch = _canvasd.h;
            canvasData.canvas = {
                width: _canvasd.w,
                height: _canvasd.h
            };

            canvas.width = _canvasd.w;
            canvas.height = _canvasd.h;

            canvasData.mask = {
                width: _canvasd.w,
                height: _canvasd.h
            };
            mask.width = _canvasd.w;
            mask.height = _canvasd.h;

            canvasData.next = {
                width: _canvasd.w,
                height: _canvasd.h
            }
            next.width = _canvasd.w;
            next.height = _canvasd.h;
        }

        function presentationInit(data) {
            canvasInit();

            presentationData.cw = parseInt(data.presentation.slideSize.cx, 10);
            presentationData.ch = parseInt(data.presentation.slideSize.cy, 10);
            slideList = data.presentation.slideIdList.reduce(function(pre, cur) {
                pre.push({rid:cur.rid, target:cur.target});
                return pre;
            }, []);
            slideInit(data, 0);
        }

        function slideInit(data, idx) {
            var layoutTarget = Object.keys(data.relations[slideList[idx].target]).filter(function(z) {
                return z.search(/^ppt\/slideLayouts\/slideLayout[0-9]+\.xml$/) > -1;
            })[0];
            var masterTarget = Object.keys(data.relations[layoutTarget]).filter(function(z) {
                return z.search(/^ppt\/slideMasters\/slideMaster[0-9]+\.xml$/) > -1;
            })[0];
            var themeTarget = Object.keys(data.relations[masterTarget]).filter(function(z) {
                return z.search(/^ppt\/theme\/theme[0-9]+\.xml$/) > -1;
            })[0];
            fontmap = {
                "+mj-lt": data.themes[themeTarget].fontScheme.majorFont.latin,
                "+mj-ea": data.themes[themeTarget].fontScheme.majorFont.fonts,
                "+mn-lt": data.themes[themeTarget].fontScheme.minorFont.latin,
                "+mn-ea": data.themes[themeTarget].fontScheme.minorFont.fonts
             };
             media = {};

             wait(data.slides[slideList[idx].rid].commonSlideData.shapes.reduce(function(pre, cur) {
             	if(cur.type === 'pic') pre.push(cur.blip.embed);
             	return pre;
             }, []).reduce(function(pre, cur) {
             	pre.push(preload(cur));
             	return pre;
             }, []), function() {
	            drawSlide(data, slideList[idx].rid, $('#canvas')[0]);
             });
             function preload(url) {
             	return function(done) {
					var img = new Image();
					img.src = url;
					img.onload = function () {
						media[url] = img;
						done();
					};
             	}
             }
        }

        function timingInit(data, idx) {
            /*var timing = data.slideList[data.slideIdList[idx].rid].timing;
             var steps = steBuilder(timing);
             steps.reduce(function(pre, cur) {
             var step = {};
             var start = '';
             }, []);*/
        }

        function stepBuilder(timing) {
            /*var root = timing.timeNodeList.parallel;
             var seq = root.childTimeNodeList.sequence.parallel;
             var steps = seq.reduce(function(pre, cur) {
             var start = cur;
             while(start.startConditionList.filter(function(cond) {if(cond.delay === 'indefinite') {return false} else {return true}}).length === 0) {
             start = start.childTimeNodeList.parallel[0];
             }
             pre.push(start);
             return pre;
             }, []);
             return steps;*/
        }

        function drawSlide(data, idx, canvas) {
            var slide = data.slides[idx];
            if (!!slide.transition) {
                var mask = $('#mask')[0];
                var next = $('#next')[0];
                var ctx_canvas = canvas.getContext('2d');
                var ctx_mask = mask.getContext('2d');
                var ctx_next = next.getContext('2d');
                ctx_next.fillStyle = slide.colorScheme[slide.colorMap[slide.commonSlideData.background]];
                ctx_next.fillRect(0, 0, next.width, next.height);
                ctx_mask.fillStyle = slide.colorScheme[slide.colorMap[slide.commonSlideData.background]];
                ctx_mask.fillRect(0, 0, mask.width, mask.height);
                slide.shapes.forEach(function (shape, idx) {
                    if (shape.type === 'shape') {
                        drawShape(slide, idx, ctx_next);
                    }
                    if (shape.type === 'pic') {
                        drawPic(slide, idx, ctx_next);
                    }
                });
                drawTransition(slide.transition, ctx_canvas, ctx_next, ctx_mask);
            } else {
                var ctx = canvas.getContext('2d');
                ctx.fillStyle = slide.colorScheme[slide.colorMap[slide.commonSlideData.background]];
                ctx.fillRect(0, 0, canvasData.cw, canvasData.ch);
                slide.commonSlideData.shapes.forEach(function (shape, idx) {
                    if (shape.type === 'shape') {
                        drawShape(slide, idx, ctx);
                    }
                    if (shape.type === 'pic') {
                        drawPic(slide, idx, ctx);
                    }
                });
            }
        }

        function drawShape(slide, idx, ctx) {
            var shape = slide.commonSlideData.shapes[idx];

            {
    			var orix = shape.x, oriy = shape.y;
    			ctx.translate(emu2pixel(orix), emu2pixel(oriy));
    			shape.x = 0, shape.y = 0;
    			//=======================
        		if(!!shape.rot) {
        			var rot = shape.rot / 21600000;
        			ctx.translate(emu2pixel(shape.cx), emu2pixel(shape.cy));
        			ctx.rotate(2 * Math.PI * rot);
        		}
            	//=======================

            	if(!!shape.solidFill) {
	                ctx.fillStyle = shape.solidFill.indexOf('#')===0 ? shape.solidFill : slide.colorScheme[slide.colorMap[shape.solidFill]];
	                if(!!drawShapes[shape.preset]) {
	            		drawShapes[shape.preset](ctx, shape);
		            	ctx.fill();
	                }
            	}
	            if(!!shape.gradFill) {
	            	var ang = shape.gradFill.ang;
	            	switch(ang) {
	            		case 0:
	            			var endx = shape.x + shape.cx;
	            			var endy = shape.y;
	            		break;
	            		case 5400000:
	            			var endx = shape.x;
	            			var endy = shape.y + shape.cy;
	            		break;
	            		case 10800000:
	            			var endx = shape.x - shape.cx;
	            			var endy = shape.y;
	            		break;
	            		case 16400000:
	            			var endx = shape.x;
	            			var endy = shape.y - shape.cy;
	            		break;
	            	}
	            	var grad = ctx.createLinearGradient(
	            		emu2pixel(shape.x), emu2pixel(shape.y), 
	            		emu2pixel(endx), 
	            		emu2pixel(endy)
	            	);
	            	shape.gradFill.stops.forEach(function(stop) {
	            		var color = stop.color;
	            		if(stop.color.indexOf('#') !== 0) {
	            			color = slide.colorScheme[slide.colorMap[color]];
	            		}
	        			if(!!stop.shade) {
	        				color = shade(color, stop.shade);
	        			}
	        			if(!!stop.tint) {
	        				color = tint(color);
	        			}
	        			grad.addColorStop(stop.pos/100000, color);
	            	});
	            	ctx.fillStyle = grad;
	                if(!!drawShapes[shape.preset]) {
	            		drawShapes[shape.preset](ctx, shape);
		            	ctx.fill();
		            }
	            }
	            if(!!shape.line && !!shape.line.color && !!shape.line.w) {
	            	var color = shape.line.color;
	            	if(color.indexOf('#') !== 0) {
	        			color = slide.colorScheme[slide.colorMap[color]];
					}
	            	if(!!shape.line.tailEnd || !!shape.line.tailEnd) {
	            		ctx.lineJoin = 'miter';
	            	}
	            	if(!!shape.line.presetDash && shape.line.presetDash.length > 1 && shape.line.presetDash !== 'solid') {
	            		var seg = [];
	            		var pat = [];
	            		switch(shape.line.presetDash) {
	            			case 'dash':
	            			pat = [4,4];
	            			break;
	            			case 'dashDot':
	            			pat = [4,3,1,3];
	            			break;
	            			case 'dot':
	            			pat = [1,3];
	            			break;
	            			case 'lgDash':
	            			pat = [8,3];
	            			break;
	            			case 'lgDashDot':
	            			pat = [8,3,1,3];
	            			break;
	            			case 'lgDashDotDot':
	            			pat = [8,3,1,3,1,3];
	            			break;
	            			case 'sysDash':
	            			pat = [3,1];
	            			break;
	            			case 'sysDashDot':
	            			pat = [3,1,1,1];
	            			break;
	            			case 'sysDashDotDot':
	            			pat = [3,1,1,1,1,1];
	            			break;
	            			case 'sysDot':
	            			pat = [1,1];
	            			break;
	            			default:
	            			throw 'presetDash pattern not supported.';
	            			break;
	            		}
	            		pat.forEach(function(s) {
	            			seg.push(emu2pixel(shape.line.w*s));
	            		});
	            		ctx.setLineDash(seg);
	            	} else {
            			ctx.setLineDash([]);
            		}
	            	ctx.lineWidth = emu2pixel(shape.line.w);
	            	ctx.strokeStyle = color;
	            	if(!!drawShapes[shape.preset]) {
	            		drawShapes[shape.preset](ctx, shape);
	            		ctx.stroke();
	            	}
	            }
            	//=======================
            	if(!!shape.rot) {
            		ctx.rotate(-2 * Math.PI * rot);
            		ctx.translate(-1 * emu2pixel(shape.cx), -1 * emu2pixel(shape.cy));
            	}
            	//=======================
            	ctx.translate(-1 * emu2pixel(orix), -1 * emu2pixel(oriy));
        		shape.x = orix;
        		shape.y = oriy;
            }
            
            //if shape outline is needed for debug
            /*ctx.strokeStyle = '#7799BB';
			ctx.strokeRect(
				emu2pixel(shape.x),
				emu2pixel(shape.y),
				emu2pixel(shape.cx),
				emu2pixel(shape.cy)
            );*/
            
            if (!!shape.textBody && !!shape.textBody.paragraphs && Array.isArray(shape.textBody.paragraphs) && shape.textBody.paragraphs.length > 0) {
                drawTextblock(shape.textBody);
            }

            function drawTextblock(block) {
                if(typeof block.lIns === 'undefined') block.lIns = 91440;
                if(typeof block.tIns === 'undefined') block.tIns = 45720;
                if(typeof block.rIns === 'undefined') block.rIns = 91440;
                if(typeof block.bIns === 'undefined') block.bIns = 45720;
                var x = shape.x + block.lIns, y = shape.y + block.tIns;
                var cx = shape.x + shape.cx - block.rIns, cy = shape.y + shape.cy - block.bIns;
                if(!!block.paragraphs && block.paragraphs.length > 0) {
	                var lineHeight1 = measureParagraph(ctx, block.paragraphs[0], false).h;
	                var textHeight = measureTextBlock(ctx, block, true).h;
                }

                if(!!block.anchor) {
                    switch(block.anchor) {
                        case 'b':
                            y = Math.round(shape.y + shape.cy - block.bIns - lineHeight1 * 0.1);
                            break;
                        case 'ctr':
                            y = Math.round(shape.y + shape.cy * 0.5 - textHeight * 0.5 + lineHeight1);
                            break;
                        default:
                        	y = Math.round(shape.y + block.tIns + lineHeight1);
                        	break;
                    }
                } else {
                	y = Math.round(shape.y + block.tIns + lineHeight1);
                }

                var txt = '';
                if(!!block.paragraphs) {
                	block.paragraphs.forEach(function(paragraph) {
                		if(!!paragraph.runs) {
                			paragraph.runs.forEach(function(run) {
                				if(run.type === 'r' && !!run.text) {
                					txt += run.text;
                				}
                			})
                		}
                	})
                }

                var linenum = 0;
                var textOffY = y;
                block.paragraphs.forEach(function (paragraph, index) {
                	if(!!paragraph.algn) {
                		var align = paragraph.algn;
                	} else {
                		align = 'l';
                	}
                    var para_line_num = 0;
                    var lineSpec = measureBreakingParagraph(ctx, paragraph);
                	switch(align) {
                		case 'r':
                			var textOffX = shape.x + shape.cx - (!!paragraph.marR?paragraph.marR:0) - block.rIns - lineSpec[para_line_num].w;
                		break;
                		case 'ctr':
                			var textOffX = shape.x + shape.cx / 2 - lineSpec[para_line_num].w / 2;
                		break;
                		default:
		                    var textOffX = x + (!!paragraph.marL?paragraph.marL:0) + (!!paragraph.indent?paragraph.indent:0);
                		break;
                	}
                    var buOffX = 0;
                    if(!!paragraph.runs) {
                        var tl = paragraph.runs.reduce(function(pre, cur) {
                            if(cur.type === 'r' && !!cur.text) {
                                pre += cur.text.length;
                            }
                            return pre;
                        }, 0);
                        if(!!paragraph.buFont && !!paragraph.buChar && !!paragraph.buClr && tl > 0) {
                            buOffX = drawText(ctx, textOffX, textOffY, paragraph.buFont, paragraph.buClr, paragraph.defRPr.sz, paragraph.buChar+' ');
                            textOffX += buOffX + paragraph.spcBef;
                        }
                        if(!!paragraph.buAutoNum && tl > 0) {
                        	var runs = paragraph.runs.filter(function(z) {return z.type === 'r' && !!z.text});
                        	if(runs.length > 0) {
                        		var run = runs[0];
                                if('undefined' === typeof run.ea || run.ea === null) run.ea = '+mj-ea';
                                if('undefined' === typeof run.latin || run.latin === null) run.latin = '+mj-lt';
                                if('undefined' === typeof run.lang || run.lang === null) run.lang = 'zh-TW';
                                
                                if(run.ea !== '+mj-ea' && run.ea !== '+mn-ea') {
                                    var buFace = run.ea;
                                } else {
                                    var tmp = fontmap[run[langmap[run.lang]]];
                                    if(typeof tmp === 'string') {
                                        var buFace = tmp;
                                    } else {
                                        var buFace = tmp[scriptmap[run.lang]];
                                    }
                                }

                                switch(paragraph.buAutoNum) {
                                	case 'circleNumWdWhitePlain':
                                		if(linenum<11) {
                                			buChar = String.fromCharCode(0x2460 + linenum);
                                		} else {
                                			buChar = linenum;
                                		}
                                	break;
                                }

	                            buOffX = drawText(ctx, textOffX, textOffY, buFace, (!!run.solidFill?run.solidFill:'tx1'), !!run.sz?run.sz:1800, buChar + ' ');
	                            textOffX += buOffX;
                        	}
                        }
                        paragraph.runs.forEach(function(run) {
                            if(run.type === 'r' && !!run.text) {
                                if('undefined' === typeof run.ea || run.ea === null) run.ea = '+mj-ea';
                                if('undefined' === typeof run.latin || run.latin === null) run.latin = '+mj-lt';
                                if('undefined' === typeof run.lang || run.lang === null) run.lang = 'zh-TW';
                                
                                if(run.ea !== '+mj-ea' && run.ea !== '+mn-ea') {
                                    var face = run.ea;
                                } else {
                                    var tmp = fontmap[run[langmap[run.lang]]];
                                    if(typeof tmp === 'string') {
                                        var face = tmp;
                                    } else {
                                        var face = tmp[scriptmap[run.lang]];
                                    }
                                }

                                for(var i=0; i<run.text.length; i++) {
                                    textOffX += drawText(ctx, textOffX, textOffY, face, (!!run.solidFill?run.solidFill:'tx2'), !!run.sz?run.sz:1800, run.text[i], run.b, run.i);
                                }
                            }
                            if(run.type === 'br') {
                                textOffY += lineSpec[para_line_num].h;
                                para_line_num++;
                                switch(align) {
                                	case 'r':
                                	textOffX = shape.x + shape.cx - (!!paragraph.marR?paragraph.marR:0) - block.rIns - lineSpec[para_line_num].w;
                                	break;
                                	case 'ctr':
                                	textOffX = shape.x + shape.cx / 2 - lineSpec[para_line_num].w / 2;
                                	break;
                                	default:
	                                textOffX = x + (!!paragraph.marL?paragraph.marL:0) + (!!paragraph.indent?paragraph.indent:0) + buOffX;
                                	break;
                                }
                            }
                            if(run.type === 'end') {
                            	//console.log('run end');
                            }
                        });
                    }
                    textOffY += lineSpec[para_line_num].h;
                    linenum++;
                });

                function drawText(ctx, hpos, vpos, font, color, size, str, b, i) {
                	var localface = '';
                	if(!!b) localface += ' 900 ';
                	if(!!i) localface += ' italic ';
                	localface += pt2pixel(size, presentationData.cw, canvasData.cw) + 'px ' + font;
                    ctx.font = localface.trim();
                    var clr = color.indexOf('#') === 0 ? color : slide.colorScheme[slide.colorMap[color]];
                    ctx.fillStyle = clr;
                    //ctx.textBaseline = 'ideographic';
                    ctx.textBaseline = '';
                    ctx.fillText(str, emu2pixel(hpos), emu2pixel(vpos));
                    var ret = pixel2emu(ctx.measureText(str).width, presentationData.cw, canvasData.cw);
                    ctx.font = '';
                    ctx.fillStyle = '';
                    return ret;
                }
            }
        }

        function measureTextBlock(ctx, block, wrap) {
            if(typeof block.lIns === 'undefined') block.lIns = 91440;
            if(typeof block.tIns === 'undefined') block.tIns = 45720;
            if(typeof block.rIns === 'undefined') block.rIns = 91440;
            if(typeof block.bIns === 'undefined') block.bIns = 45720;
        	var tmp = block.paragraphs.reduce(function(pre, cur) {
        		var tmp = measureParagraph(ctx, cur, wrap);
        		pre.w += tmp.w;
        		pre.h += tmp.h;
        		return pre;
        	}, {w: 0, h: 0});
        	tmp.w += block.lIns + block.rIns;
        	tmp.h += block.tIns + block.bIns;
        	return tmp;
        }

        function measureBreakingParagraph(ctx, paragraph) {
        	var ret = {w: 0, h: 0};
    		var lh = paragraph.runs.reduce(function(pre, cur) {
    			if(cur.type === 'r' && cur.sz > pre) pre = cur.sz;
    			return pre;
    		}, 1800);
			var lineHeight = Math.round(pixel2emu(pt2pixel(lh, presentationData.cw, canvasData.cw) * 1.05));
    		ret.h = lineHeight;
    		var tmpwidth = [];
    		paragraph.runs.forEach(function(run) {
                if('undefined' === typeof run.ea || run.ea === null) run.ea = '+mj-ea';
                if('undefined' === typeof run.latin || run.latin === null) run.latin = '+mj-lt';
                if('undefined' === typeof run.lang || run.lang === null) run.lang = 'zh-TW';
                
                if(run.ea !== '+mj-ea' && run.ea !== '+mn-ea') {
                    var face = run.ea;
                } else {
                    var tmp = fontmap[run[langmap[run.lang]]];
                    if(typeof tmp === 'string') {
                        var face = tmp;
                    } else {
                        var face = tmp[scriptmap[run.lang]];
                    }
                }
    			if(run.type === 'br') {
    				tmpwidth.push(ret.w);
    				ret.w = 0;
    			}
    			if(run.type === 'r') {
    				if(!!run.text && run.text.length > 0) {
        				ret.w += measureText(ctx, run.text, face, !!run.sz?run.sz:1800, run.b, run.i);
    				}
    			}
    		});
			tmpwidth.push(ret.w);
			return tmpwidth.reduce(function(pre, cur) {
				pre.push({w: cur, h: ret.h});
				return pre;
			}, []);
        }

        function measureParagraph(ctx, paragraph, wrap) {
        	var ret = {w: 0, h: 0};
    		var lh = paragraph.runs.reduce(function(pre, cur) {
    			if(cur.type === 'r' && cur.sz > pre) pre = cur.sz;
    			return pre;
    		}, 1800);
    		var lineHeight = Math.round(pixel2emu(pt2pixel(lh, presentationData.cw, canvasData.cw) * 1.05, presentationData.cw, canvasData.cw));
        	if(wrap) {
        		ret.h = lineHeight;
        		var tmpwidth = [];
        		paragraph.runs.forEach(function(run) {
                    if('undefined' === typeof run.ea || run.ea === null) run.ea = '+mj-ea';
                    if('undefined' === typeof run.latin || run.latin === null) run.latin = '+mj-lt';
                    if('undefined' === typeof run.lang || run.lang === null) run.lang = 'zh-TW';
                    
                    if(run.ea !== '+mj-ea' && run.ea !== '+mn-ea') {
                        var face = run.ea;
                    } else {
                        var tmp = fontmap[run[langmap[run.lang]]];
                        if(typeof tmp === 'string') {
                            var face = tmp;
                        } else {
                            var face = tmp[scriptmap[run.lang]];
                        }
                    }
        			if(run.type === 'br') {
        				ret.h += lineHeight;
        				tmpwidth.push(ret.w);
        				ret.w = 0;
        			}
        			if(run.type === 'r') {
        				if(!!run.text && run.text.length > 0) {
            				ret.w += measureText(ctx, run.text, face, !!run.sz?run.sz:1800, run.b, run.i);
        				}
        			}
        		});
				if(tmpwidth.length > 0) {
					ret.w = tmpwidth[0];
				}
        	} else {
        		ret.h = lineHeight;
        		paragraph.runs.forEach(function(run) {
                    if('undefined' === typeof run.ea || run.ea === null) run.ea = '+mj-ea';
                    if('undefined' === typeof run.latin || run.latin === null) run.latin = '+mj-lt';
                    if('undefined' === typeof run.lang || run.lang === null) run.lang = 'zh-TW';
                    
                    if(run.ea !== '+mj-ea' && run.ea !== '+mn-ea') {
                        var face = run.ea;
                    } else {
                        var tmp = fontmap[run[langmap[run.lang]]];
                        if(typeof tmp === 'string') {
                            var face = tmp;
                        } else {
                            var face = tmp[scriptmap[run.lang]];
                        }
                    }
        			if(run.type === 'r') {
        				if(!!run.text && run.text.length > 0) {
            				ret.w += measureText(ctx, run.text, face, !!run.sz?run.sz:1800, run.b, run.i);
        				}
        			}
        		});
        	}
        	ret.w += (!!paragraph.marL?paragraph.marL:0) + (!!paragraph.marR?paragraph.marR:0);
			return ret;
        }

        function measureText(ctx, str, font, size, b, i) {
			var localface = '';
			var ret = 0;
        	if(!!b) localface += ' 900 ';
        	if(!!i) localface += ' italic ';
        	localface += pt2pixel(size, presentationData.cw, canvasData.cw) + 'px ' + font;
            ctx.font = localface.trim();
            var tmp = ctx.measureText(str).width;
            ret += pixel2emu(tmp, presentationData.cw, canvasData.cw);
            return ret;
        }

        function drawPic(slide, idx, ctx) {
            var pic = slide.commonSlideData.shapes[idx];
            var img = media[pic.blip.embed];
        	if(typeof pic.blip.srcRect === 'undefined') pic.blip.srcRect = {l:0, r:0, t:0, b:0};
            var picx = img.width, picy = img.height;
            var l = pic.blip.srcRect.l / 100000, r = pic.blip.srcRect.r / 100000, t = pic.blip.srcRect.t / 100000, b = pic.blip.srcRect.b / 100000;
            var offx = pic.x, offy = pic.y;
            var cx = pic.cx, cy = pic.cy;

            var sx = Math.round(picx * l), sy = Math.round(picy * t);
            var sw = Math.round(picx - picx * (l + r)), sh = Math.round(picy - picy * (t + b));
            var dx = emu2pixel(offx), dy = emu2pixel(offy);
            var dw = emu2pixel(cx), dh = emu2pixel(cy);
            ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
        }

        function drawTransition(transition, target, next, mask) {
            var start = null;
            requestAnimationFrame(transitionAnimate);
            function transitionAnimate(t) {
                if (start === null) {
                    start = t;
                    requestAnimationFrame(transitionAnimate);
                } else {
                    var progress = (t - start) / transition.duration;
                    mask.fillStyle = '#FFFFFF';
                    mask.fillRect(0, 0, canvasData.canvas.width, canvasData.canvas.height);
                    drawTransitionPattern(transition, mask, progress);
                    var x = 0, y = 0;
                    var maskImg = mask.getImageData(0, 0, canvasData.cw, canvasData.ch);
                    var nextImg = next.getImageData(0, 0, canvasData.cw, canvasData.ch);
                    var targetImg = target.getImageData(0, 0, canvasData.cw, canvasData.ch);
                    var output = target.createImageData(targetImg);
                    for (var i = 0; i < targetImg.data.length; i += 4) {
                        if (maskImg.data[i] == 0 && maskImg.data[i + 1] == 0 && maskImg.data[i + 2] == 0) {
                            output.data[i] = nextImg.data[i];
                            output.data[i + 1] = nextImg.data[i + 1];
                            output.data[i + 2] = nextImg.data[i + 2];
                            output.data[i + 3] = 255;
                        } else {
                            output.data[i] = targetImg.data[i];
                            output.data[i + 1] = targetImg.data[i + 1];
                            output.data[i + 2] = targetImg.data[i + 2];
                            output.data[i + 3] = 255;
                        }
                    }
                    target.putImageData(output, 0, 0);
                    if (t - start < transition.duration) {
                        requestAnimationFrame(transitionAnimate);
                    }
                }
            }
        }

        function drawTransitionPattern(transition, mask, progress) {
            switch (transition.type) {
                case 'comb':
                    var num = 8;
                    var start = 0;
                    var side = 0;
                    if (transition.dir === 'horz') {
                        var bh = Math.round(canvasData.ch / num);
                        while (start < canvasData.ch) {
                            mask.fillStyle = '#000000';
                            if (side % 2 === 0) {
                                mask.fillRect(0, start, Math.round(progress * canvasData.cw), bh);
                            } else {
                                var l = Math.round(canvasData.cw * (1 - progress));
                                mask.fillRect(Math.round(canvasData.cw * (1 - progress)), start, canvasData.cw - l, bh);
                            }
                            start += bh;
                            side++;
                        }
                    } else {
                        var bw = Math.round(canvasData.cw / num);
                        while (start < canvasData.cw) {
                            mask.fillStyle = '#000000';
                            if (side % 2 === 0) {
                                mask.fillRect(start, 0, bw, Math.round(progress * canvasData.ch));
                            } else {
                                var t = Math.round(canvasData.ch * (1 - progress));
                                mask.fillRect(start, Math.round(canvasData.ch * (1 - progress)), bw, canvasData.ch - t);
                            }
                            start += bw;
                            side++;
                        }
                    }
                    break;
            }
        }

        function pt2pixel(sz) {
        	var screenw = presentationData.cw, canvasw = canvasData.cw;
            return sz * 914400 * canvasw / 100 / 72 / screenw;
        }

        function emu2pixel(l) {
        	var screenw = presentationData.cw, canvasw = canvasData.cw;
            return l * canvasw / screenw;
        }

        function pixel2emu(l) {
        	var screenw = presentationData.cw, canvasw = canvasData.cw;
            return l * screenw / canvasw;
        }

        function calculateCanvasWidth(vzw, vzh) {
            if (vzh / 3 * 4 < vzw) {
                return {w: Math.round((vzh - 20) * 4 / 3), h: vzh - 20};
            } else {
                return {w: vzw - Math.round(20 * 4 / 3), h: Math.round(vzw * 3 / 4) - 20};
            }
        }

        function define_quadratic_bezier(x0, y0, x1, y1, x2, y2) {
            return function (t) {
                if (t < 0 || t > 1) throw "[define_quadratic_bezier] t must between 0 and 1.";
                var px = Math.pow(1 - t, 2) * x0 + 2 * t * (1 - t) * x1 + Math.pow(t, 2) * x2;
                var py = Math.pow(1 - t, 2) * y0 + 2 * t * (1 - t) * y1 + Math.pow(t, 2) * y2;
                return [px, py];
            };
        }

        //this easing is from jquery's swing
        function easing(p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        }
        
        function wait(f, n) {
        	var count = f.length;
        	f.forEach(function(g) {
        		g(done);
        	});
        	function done() {
        		count--;
        		if(count <= 0) {
        			n();
        		}
        	}
        }

        function shade(color, fact) {
        	color = color.trim();
        	fact = fact / 100000;
        	if(color.indexOf('#') === 0) {
        		var c = color.substr(1);
        	} else {
        		var c = color;
        	}
    		var r = parseInt(c.substr(0, 2), 16);
    		var g = parseInt(c.substr(2, 2), 16);
    		var b = parseInt(c.substr(4, 2), 16);
    		r = Math.round(r * (1 - fact<1?fact:fact/100000));
    		g = Math.round(g * (1 - fact<1?fact:fact/100000));
    		b = Math.round(b * (1 - fact<1?fact:fact/100000));
    		return '#' + padHex(r, 2).toUpperCase() + padHex(g, 2).toUpperCase() + padHex(b, 2).toUpperCase();
        }

        function tint(color, fact) {
        	color = color.trim();
        	if(color.indexOf('#') === 0) {
        		var c = color.substr(1);
        	} else {
        		var c = color;
        	}
    		var r = parseInt(c.substr(0, 2), 16);
    		var g = parseInt(c.substr(2, 2), 16);
    		var b = parseInt(c.substr(4, 2), 16);
    		r = Math.round(r + (255 - r) * fact<1?fact:fact/100000);
    		g = Math.round(g + (255 - g) * fact<1?fact:fact/100000);
    		b = Math.round(b + (255 - b) * fact<1?fact:fact/100000);
    		return '#' + padHex(r, 2).toUpperCase() + padHex(g, 2).toUpperCase() + padHex(b, 2).toUpperCase();
        }

        function padHex(input, l) {
        	if(typeof input !== 'string') {
        		input = input.toString(16);
        	}
        	var ret = input;
        	for(var i=0; i<l-input.length; i++) {
        		ret = '0' + ret;
        	}
        	return ret;
        }
        var drawShapes = {
        	'cust': function(ctx, shape) {
        		shape.presetGeom.pathList.forEach(function(path) {
	        		var gd = new Guides(ctx, shape.cx, shape.cy, function(x){return emu2pixel(x) * (shape.cx>shape.cy?shape.cy:shape.cx) / (shape.cx>shape.cy?path.h:path.w)});
	        		gd.begin();
	        		path.actions.forEach(function(action) {
	        			if(!!gd[action.name] && typeof gd[action.name] === 'function') {
	        				var args = action.pts.reduce(function(pre, cur) {
	        					pre.push(cur.x);
	        					pre.push(cur.y);
	        					return pre;
	        				}, []);
	        				gd[action.name].apply(gd, args);
	        			} else {
	        				throw "Action not supported.";
	        			}
	        		});
	        		gd.close();
        		});
        	},
        	'rect': function(ctx, shape) {
        		var gd = new Guides(ctx, shape.cx, shape.cy, emu2pixel);
        		gd.moveTo(gd.l, gd.t);
        		gd.begin();
        		gd.lineTo(gd.r, gd.t);
        		gd.lineTo(gd.r, gd.b);
        		gd.lineTo(gd.l, gd.b);
        		gd.lineTo(gd.l, gd.t);
        		gd.close();
        	},
        	'downArrow': function(ctx, shape) {
        		var gd = new Guides(ctx, shape.cx, shape.cy, emu2pixel);
        		shape.presetGeom.avList.forEach(function(a) {
        			gd.addFormula(a.name, a.fmla);
        		})
        		gd.addFormula('maxAdj2', '*/ 100000 h ss');
        		gd.addFormula('a1', 'pin 0 adj1 100000');
        		gd.addFormula('a2', 'pin 0 adj2 maxAdj2');
        		gd.addFormula('dy1', '*/ ss a2 100000');
        		gd.addFormula('y1', '+- b 0 dy1');
        		gd.addFormula('dx1', '*/ w a1 200000');
        		gd.addFormula('x1', '+- hc 0 dx1');
        		gd.addFormula('x2', '+- hc dx1 0');
        		gd.addFormula('dy2', '*/ x1 dy1 wd2');
        		gd.addFormula('y2', '+- y1 dy2 0');

        		gd.moveTo(gd.l, gd.y1);
        		gd.begin();
        		gd.lineTo(gd.x1, gd.y1);
        		gd.lineTo(gd.x1, gd.t);
        		gd.lineTo(gd.x2, gd.t);
        		gd.lineTo(gd.x2, gd.y1);
        		gd.lineTo(gd.r, gd.y1);
        		gd.lineTo(gd.hc, gd.b);
        		gd.lineTo(gd.l, gd.y1);
        		gd.close();
    		},
    		'line': function(ctx, shape) {
        		var gd = new Guides(ctx, shape.cx, shape.cy, emu2pixel);

        		if(!!shape.line && !!shape.line.w) {
        			gd.addFormula('adj', 'val ' + (shape.line.w));
					gd.addFormula('a1', '*/ adj 3 2');
					gd.addFormula('a2', '*/ adj 2 3');
        			if(!!shape.line.headEnd) {
        				switch(shape.line.headEnd) {
        					case 'triangle':
        						if(shape.cx > shape.cy) {
	        						gd.addFormula('tx1', '+- l a1 0');
	        						gd.addFormula('ty2', '+- t 0 a2');
	        						gd.addFormula('ty4', '+- t a2 0');
        						} else {
        							gd.addFormula('ty1', '+- t a1 0');
        							gd.addFormula('tx2', '+- l a2 0');
        							gd.addFormula('tx4', '+- l 0 a2');
        						}
        					break;
        				}
        			}
        			if(!!shape.line.tailEnd) {
        				switch(shape.line.tailEnd) {
        					case 'triangle':
        						if(shape.cx > shape.cy) {
		    						gd.addFormula('tx6', '+- r 0 a1');
	        						gd.addFormula('ty7', '+- b a2 0');
	        						gd.addFormula('ty9', '+- b 0 a2');
        						} else {
        							gd.addFormula('ty6', '+- b 0 a1');
        							gd.addFormula('tx7', '+- r a2 0');
        							gd.addFormula('tx9', '+- r 0 a2');
        						}
        					break;
        				}
        			}
        		}
        		if(!!shape.line && !!shape.line.w && !!shape.line.headEnd) {
        			switch(shape.line.headEnd) {
        				case 'triangle':
        					if(shape.cx > shape.cy) {
	        					gd.moveTo(gd.tx1, gd.t);
        					} else {
        						gd.moveTo(gd.l, gd.ty1);
        					}
        				break;
        			}
        		} else {
	        		gd.moveTo(gd.l, gd.t);
        		}
        		gd.begin();
        		if(!!shape.line && !!shape.line.w && !!shape.line.headEnd) {
        			switch(shape.line.headEnd) {
        				case 'triangle':
        					if(shape.cx > shape.cy) {
	        					gd.lineTo(gd.tx1, gd.ty2);
	        					gd.lineTo(gd.l, gd.t);
	        					gd.lineTo(gd.tx1, gd.ty4);
	        					gd.lineTo(gd.tx1, gd.t);
        					} else {
        						gd.lineTo(gd.tx2, gd.ty1);
        						gd.lineTo(gd.l, gd.t);
        						gd.lineTo(gd.tx4, gd.ty1);
        						gd.lineTo(gd.l, gd.ty1);
        					}
        				break;
        			}
        		}
        		if(!!shape.line && !!shape.line.w && !!shape.line.tailEnd) {
        			switch(shape.line.tailEnd) {
        				case 'triangle':
        					if(shape.cx > shape.cy) {
			        			gd.lineTo(gd.tx6, gd.b);
			        			gd.lineTo(gd.tx6, gd.ty7);
			        			gd.lineTo(gd.r, gd.b);
			        			gd.lineTo(gd.tx6, gd.ty9);
			        			gd.lineTo(gd.tx6, gd.b);
        					} else {
        						gd.lineTo(gd.r, gd.ty6);
        						gd.lineTo(gd.tx7, gd.ty6);
        						gd.lineTo(gd.r, gd.b);
        						gd.lineTo(gd.tx9, gd.ty6);
        						gd.lineTo(gd.r, gd.ty6);
        					}
        				break;
        			}
        		} else {
	        		gd.lineTo(gd.r, gd.b);
        		}
        		if(!!shape.line && !!shape.line.w && !!shape.line.headEnd) {
        			switch(shape.line.headEnd) {
        				case 'triangle':
        					if(shape.cx > shape.cy) {
			        			gd.lineTo(gd.tx1, gd.t);
        					} else {
        						gd.lineTo(gd.l, gd.ty1);
        					}
        				break;
        			}
        		} else {
	        		gd.lineTo(gd.l, gd.t);
        		}
        		gd.close();
    		},
    		'notchedRightArrow': function(ctx, shape) {
        		var gd = new Guides(ctx, shape.cx, shape.cy, emu2pixel);
        		shape.presetGeom.avList.forEach(function(a) {
        			gd.addFormula(a.name, a.fmla);
        		});

        		gd.addFormula('maxAdj2', '*/ 100000 w ss');
        		gd.addFormula('a1', 'pin 0 adj1 100000');
        		gd.addFormula('a2', 'pin 0 adj2 maxAdj2');
        		gd.addFormula('dx2', '*/ ss a2 100000');
        		gd.addFormula('x2', '+- r 0 dx2');
        		gd.addFormula('dy1', '*/ h a1 200000');
        		gd.addFormula('y1', '+- vc 0 dy1');
        		gd.addFormula('y2', '+- vc dy1 0');
        		gd.addFormula('x1', '*/ dy1 dx2 hd2');
        		gd.addFormula('x3', '+- r 0 x1');

        		gd.moveTo(gd.l, gd.y1);
        		gd.begin();
        		gd.lineTo(gd.x2, gd.y1);
        		gd.lineTo(gd.x2, gd.t);
        		gd.lineTo(gd.r, gd.vc);
        		gd.lineTo(gd.x2, gd.b);
        		gd.lineTo(gd.x2, gd.y2);
        		gd.lineTo(gd.l, gd.y2);
        		gd.lineTo(gd.x1, gd.vc);
        		gd.lineTo(gd.l, gd.y1);
        		gd.close();
    		},
    		'leftBrace': function(ctx, shape) {
        		var gd = new Guides(ctx, shape.cx, shape.cy, emu2pixel);
        		shape.presetGeom.avList.forEach(function(a) {
        			gd.addFormula(a.name, a.fmla);
        		})

        		gd.addFormula('a2', 'pin 0 adj2 100000');
        		gd.addFormula('q1', '+- 100000 0 a2');
        		gd.addFormula('q2', 'min q1 a2');
        		gd.addFormula('q3', '*/ q2 1 2');
        		gd.addFormula('maxAdj1', '*/ q3 h ss');
        		gd.addFormula('a1', 'pin 0 adj1 maxAdj1');
        		gd.addFormula('y1', '*/ ss a1 100000');
        		gd.addFormula('y3', '*/ h a2 100000');
        		gd.addFormula('y4', '+- y3 y1 0');
        		gd.addFormula('dx1', 'cos wd2 2700000');
        		gd.addFormula('dy1', 'sin y1 2700000');
        		gd.addFormula('il', '+- r 0 dx1');
        		gd.addFormula('it', '+- y1 0 dy1');
        		gd.addFormula('ib', '+- b dy1 y1');

        		gd.moveTo(gd.r, gd.b);
        		gd.begin();
        		gd.arcTo(gd.wd2, gd.y1, gd.cd4, gd.cd4);
        		gd.lineTo(gd.hc, gd.y4);
        		gd.arcTo(gd.wd2, gd.y1, 0, -5400000);
        		gd.arcTo(gd.wd2, gd.y1, gd.cd4, -5400000);
        		gd.lineTo(gd.hc, gd.y1);
        		gd.arcTo(gd.wd2, gd.y1, gd.cd2, gd.cd4);

    		},
    		'triangle': function(ctx, shape) {
        		var gd = new Guides(ctx, shape.cx, shape.cy, emu2pixel);
        		shape.presetGeom.avList.forEach(function(a) {
        			gd.addFormula(a.name, a.fmla);
        		})

        		gd.addFormula('a', 'pin 0 adj 100000');
        		gd.addFormula('x1', '*/ w a 200000');
        		gd.addFormula('x2', '*/ w a 100000');
        		gd.addFormula('x3', '+- x1 wd2 0');

        		gd.moveTo(gd.l, gd.b);
        		gd.begin();
        		gd.lineTo(gd.x2, gd.t);
        		gd.lineTo(gd.r, gd.b);
        		gd.lineTo(gd.l, gd.b);
        		gd.close();
    		},
    		'ellipse': function(ctx, shape) {
        		var gd = new Guides(ctx, shape.cx, shape.cy, emu2pixel);

        		gd.addFormula('idx', 'cos wd2 2700000');
        		gd.addFormula('idy', 'sin hd2 2700000');
        		gd.addFormula('il', '+- hc 0 idx');
        		gd.addFormula('ir', '+- hc idx 0');
        		gd.addFormula('it', '+- vc 0 idy');
        		gd.addFormula('ib', '+- vc idy 0');

        		gd.moveTo(gd.l, gd.vc);
        		gd.begin();
        		gd.arcTo(gd.wd2, gd.hd2, gd.cd2, gd.cd4);
        		gd.arcTo(gd.wd2, gd.hd2, gd['3cd4'], gd.cd4);
        		gd.arcTo(gd.wd2, gd.hd2, 0, gd.cd4);
        		gd.arcTo(gd.wd2, gd.hd2, gd.cd4, gd.cd4);
        		gd.close();
    		}
        };

        function Guides(ctx, w, h, _c) {
        	if(!!_c && typeof _c === 'function') {
        		this.conv = _c;
        	} else {
        		if(!!emu2pixel && typeof emu2pixel === 'function') this.conv = emu2pixel;
        		this.conv = function(n){return n};
        	}
        	var cur = {x:0,y:0};
        	this.w = w;
        	this.h = h;
        	this.l = 0;
        	this.t = 0;
        	this['3cd4'] = 16200000;
        	this['3cd8'] = 8100000;
        	this['5cd8'] = 13500000;
        	this['7cd8'] = 18900000;
        	this.b = h;
        	this.r = w;
        	this.cd2 = 10800000;
        	this.cd4 = 5400000;
        	this.cd8 = 2700000;
        	this.factor = 2 * Math.PI / 21600000;
        	parse.call(this, 'hc', '*/ w 1 2');
        	parse.call(this, 'hd2', '*/ h 1 2');
        	parse.call(this, 'hd3', '*/ h 1 3');
        	parse.call(this, 'hd4', '*/ h 1 4');
        	parse.call(this, 'hd5', '*/ h 1 5');
        	parse.call(this, 'hd6', '*/ h 1 6');
        	parse.call(this, 'hd8', '*/ h 1 8');
        	parse.call(this, 'ls', 'max w h');
        	parse.call(this, 'ss', 'min w h');
        	parse.call(this, 'ssd2', '*/ ss 1 2');
        	parse.call(this, 'ssd4', '*/ ss 1 4');
        	parse.call(this, 'ssd6', '*/ ss 1 6');
        	parse.call(this, 'ssd8', '*/ ss 1 8');
        	parse.call(this, 'ssd16', '*/ ss 1 16');
        	parse.call(this, 'ssd32', '*/ ss 1 32');
        	parse.call(this, 'vc', '*/ h 1 2');
        	parse.call(this, 'wd2', '*/ w 1 2');
        	parse.call(this, 'wd3', '*/ w 1 3');
        	parse.call(this, 'wd4', '*/ w 1 4');
        	parse.call(this, 'wd5', '*/ w 1 5');
        	parse.call(this, 'wd6', '*/ w 1 6');
        	parse.call(this, 'wd8', '*/ w 1 8');
        	parse.call(this, 'wd10', '*/ 1 10');

        	this.addFormula = function(name, fmla) {
        		parse.call(this, name, fmla);
        	};

        	this.lineTo = function(x, y) {
        		ctx.lineTo(this.conv(x), this.conv(y));
        		cur.x = x, cur.y = y;
        	};

        	this.lnTo = this.lineTo;

        	this.moveTo = function(x, y) {
        		ctx.moveTo(this.conv(x), this.conv(y));
        		cur.x = x, cur.y = y;
        	};

        	this.begin = function() {
        		ctx.beginPath();
        	};

        	this.close = function() {
        		ctx.closePath();
        	};

        	this.arcTo = function(hr, vr, sta, swa) {
        		if(swa < 0) {
        			var anticlock = true;
        			if(sta + swa < 0) {
        				var end = sta + swa + 21600000;
        			} else {
        				var end = sta + swa;
        			}
        		} else {
        			var anticlock = false;
        			var end = sta + swa;
        		}
        		var ecx = cur.x - hr * Math.cos(sta * 2 * Math.PI / 21600000);
        		var ecy = cur.y - vr * Math.sin(sta * 2 * Math.PI / 21600000);
        		ctx.ellipse(this.conv(ecx), this.conv(ecy), this.conv(hr), this.conv(vr), 0, sta * 2 * Math.PI / 21600000, end * 2 * Math.PI / 21600000, anticlock);
    			cur.x = ecx + hr * Math.cos(end * 2 * Math.PI / 21600000);
    			cur.y = ecy + vr * Math.sin(end * 2 * Math.PI / 21600000);
        	};

        	this.cubicBezTo = function(x1, y1, x2, y2, x, y) {
        		ctx.bezierCurveTo(this.conv(x1), this.conv(y1), this.conv(x2), this.conv(y2), this.conv(x), this.conv(y));
        		cur.x = x, cur.y = y;
        	};

        	function parse(name, fmla) {
        		var key = fmla.split(/[ ]+/)[0];
        		var args = fmla.split(/[ ]+/).slice(1);
        		var circle = 21600;
        		var factor = 2 * Math.PI / circle;
        		var formulas = {
        			"+-": function(a, b, c) {
        				return a + b - c;
        			},
        			"+/": function(a, b, c) {
        				return (a + b) / c;
        			},
        			"*/": function(a, b, c) {
        				return a * b / c;
        			},
        			"?:": function(a, b, c) {
        				return a>0?b:c;
        			},
        			"abs": function(a) {
        				return Math.abs(a);
        			},
        			"at2": function(a, b) {
        				return Math.atan(b/a*factor);
        			},
        			"cat2": function(a, b, c) {
        				return a * Math.cos(Math.atan(c/b*factor)*factor);
        			},
        			"cos": function(a, b) {
        				return a * Math.cos(b*factor);
        			},
        			"max": function(a, b) {
        				return a>b?a:b;
        			},
        			"min": function(a, b) {
        				return a>b?b:a;
        			},
        			"mod": function(a, b, c) {
        				return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2));
        			},
        			"pin": function(a, b, c) {
        				return b<a?a:b>c?c:b;
        			},
        			"sat2": function(a, b, c) {
        				return a * Math.sin(Math.atan(c/b*factor)*factor);
        			},
        			"sin": function(a, b) {
        				return a * Math.sin(b*factor);
        			},
        			"sqrt": function(a) {
        				return Math.sqrt(a);
        			},
        			"tan": function(a, b) {
        				return a * Math.tan(b*factor);
        			},
        			"val": function(a) {
        				if(isNaN(parseInt(a, 10))) return a;
        				return parseInt(a, 10);
        			}
        		};
        		var that = this;
        		var _args = args.reduce(function(pre, cur) {
        			if(isNaN(parseInt(cur, 10))) {
        				pre.push(that[cur]);
        			} else {
        				pre.push(parseInt(cur, 10));
        			}
        			return pre;
        		}, []);
        		if(!!formulas[key]) {
        			this[name] = formulas[key].apply(this, _args);
        		} else {
        			throw "Operator or function not supported.";
        		}
        	}
        }
    });
</script>
</body>
</html>
