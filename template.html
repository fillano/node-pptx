<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            background-color: white;
        }

        .mask_canvas {
            position: absolute;
            top: -50000px;
            left: -50000px;
        }

        .next_canvas {
            position: absolute;
            top: -100000px;
            left: -100000px;
        }
    </style>
</head>
<body style="background-color: #000;text-align: center;padding:0 0 0 0; margin: 0 0 0 0">
<canvas id="canvas" width="800" height="600"></canvas>
<canvas id="mask" class="mask_canvas" width="800" height="600"></canvas>
<canvas id="next" class="next_canvas" width="800" height="600"></canvas>
<br>
<button id="step1">上一步</button>
<button id="step2">下一步</button>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
<script src="drawshapes.js"></script>
<script src="main.js"></script>
<script>
    $(function () {
        var canvas = $('#canvas')[0];

        var presentationData = {};

        var canvasData = {};

        var slideList = [];

        var currentSlide = 0;
        var currentStep = 0;
        var steps = [];
        var builds = [];

        var media = {};

        var langmap = {
            "zh-TW": "ea",
            "zh-CN": "ea",
            "en-US": "latin",
            "en-GB": "latin"
        };

        var scriptmap = {
            "zh-TW": 'Hant',
            "zh-CN": 'Hans'
        };
        var fontmap = {};

        presentationInit(data);

        $('#step1').click(function() {
            if(currentSlide > 0) {
                currentSlide--;
                slideInit(data, currentSlide);
            }
        });
        $('#step2').click(function() {
            if(currentSlide < slideList.length-1) {
                currentSlide++;
                slideInit(data, currentSlide);
            }
        });

        $(document).on('keyup', function(e) {
            if(e.keyCode === 39 || e.keyCode === 32) {
                if(currentSlide < slideList.length-1) {
                    currentSlide++;
                    slideInit(data, currentSlide);
                }
            }
            if(e.keyCode === 37) {
                if(currentSlide > 0) {
                    currentSlide--;
                    slideInit(data, currentSlide);
                }
            }
        });

        function canvasInit() {
            var vzw = document.documentElement.clientWidth;
            var vzh = document.documentElement.clientHeight;
            var _canvasd = calculateCanvasWidth(vzw, vzh);
            var canvas = $('#canvas')[0];
            var mask = $('#mask')[0];
            var next = $('#next')[0];

            canvasData.cw = _canvasd.w;
            canvasData.ch = _canvasd.h;
            canvasData.canvas = {
                width: _canvasd.w,
                height: _canvasd.h
            };

            canvas.width = _canvasd.w;
            canvas.height = _canvasd.h;

            canvasData.mask = {
                width: _canvasd.w,
                height: _canvasd.h
            };
            mask.width = _canvasd.w;
            mask.height = _canvasd.h;

            canvasData.next = {
                width: _canvasd.w,
                height: _canvasd.h
            }
            next.width = _canvasd.w;
            next.height = _canvasd.h;
        }

        function presentationInit(data) {
            canvasInit();

            presentationData.cw = parseInt(data.presentation.slideSize.cx, 10);
            presentationData.ch = parseInt(data.presentation.slideSize.cy, 10);
            slideList = data.presentation.slideIdList.reduce(function(pre, cur) {
                pre.push({rid:cur.rid, target:cur.target});
                return pre;
            }, []);
            slideInit(data, 0);
        }

        function slideInit(data, idx) {
            var layoutTarget = Object.keys(data.relations[slideList[idx].target]).filter(function(z) {
                return z.search(/^ppt\/slideLayouts\/slideLayout[0-9]+\.xml$/) > -1;
            })[0];
            var masterTarget = Object.keys(data.relations[layoutTarget]).filter(function(z) {
                return z.search(/^ppt\/slideMasters\/slideMaster[0-9]+\.xml$/) > -1;
            })[0];
            var themeTarget = Object.keys(data.relations[masterTarget]).filter(function(z) {
                return z.search(/^ppt\/theme\/theme[0-9]+\.xml$/) > -1;
            })[0];
            fontmap = {
                "+mj-lt": data.themes[themeTarget].fontScheme.majorFont.latin,
                "+mj-ea": data.themes[themeTarget].fontScheme.majorFont.fonts,
                "+mn-lt": data.themes[themeTarget].fontScheme.minorFont.latin,
                "+mn-ea": data.themes[themeTarget].fontScheme.minorFont.fonts
            };
            media = {};

            wait(data.slides[slideList[idx].rid].commonSlideData.shapes.reduce(function(pre, cur) {
                if(cur.type === 'pic') pre.push(cur.blip.embed);
                return pre;
            }, []).reduce(function(pre, cur) {
                pre.push(preload(cur));
                return pre;
            }, []), function() {
                var slide = Object.assign({}, data.slides[slideList[idx].rid]);
                steps = [];
                builds = [];
                timingInit(slide);
                drawSlide(slide, $('#canvas')[0]);
            });
            function preload(url) {
                return function(done) {
                    var img = new Image();
                    img.src = url;
                    img.onload = function () {
                        media[url] = img;
                        done();
                    };
                }
            }
        }

        function timingInit(slide) {
            var timing = slide.timing;
            steps = stepBuilder(timing);
            if(!!timing.bldLst) {
                builds = timing.bldLst;
            }
            steps.forEach(function(step) {
                stepWalker(step, slide.commonSlideData.shapes, function(shape) {
                    if(!!shape.style) {
                        shape.style.visibility = 'invisible';
                    } else {
                        shape.style = {visibility: 'invisible'};
                    }
                });
            });
            builds.forEach(function(bld) {
                slide.commonSlideData.shapes.forEach(function(shape) {
                    if(parseInt(shape.id, 10) === parseInt(bld.spid, 10)) {
                        if(!!shape.style) {
                            shape.style.visibility = 'invisible';
                        } else {
                            shape.style = {visibility: 'invisible'};
                        }
                    }
                });
            });
        }

        function stepWalker(step, shapes, cb) {
            if(step.name === 'p:set') {
                if(!!step.attrNameLst && step.attrNameLst.length > 0) {
                    var e = step.attrNameLst.filter(function(x) {return x.val === 'style.visibility' && x.name === 'p:attrName'});
                    if(e.length > 0) {
                        var target = step.tgtEl;
                        shapes.forEach(function(shape) {
                            if(parseInt(shape.id, 10) === parseInt(target, 10)) {
                                cb(shape);
                            }
                        });
                    }
                }
            }
            if(!!step.childTnLst) {
                step.childTnLst.forEach(function(next) {
                   stepWalker(next, shapes, cb);
                });
            }
        }

        function stepBuilder(timing) {
            var ret = [];
            timing.tnLst.forEach(function(tn) {
                if(tn.nodeType === 'tmRoot' && !!tn.childTnLst) {
                    tn.childTnLst.forEach(function(tn) {
                        if(tn.nodeType === 'mainSeq' && !!tn.childTnLst) {
                           tn.childTnLst.forEach(function(tn) {
                               if(tn.nodeType === 'clickPar') {
                                   ret.push(tn);
                               }
                           });
                        }
                    });
                }
            });
            return ret;
        }

        function drawSlide(slide, canvas) {
            if (!!slide.transition) {
                var mask = $('#mask')[0];
                var next = $('#next')[0];
                var ctx_canvas = canvas.getContext('2d');
                var ctx_mask = mask.getContext('2d');
                var ctx_next = next.getContext('2d');
                ctx_next.fillStyle = slide.colorScheme[slide.colorMap[slide.commonSlideData.background]];
                ctx_next.fillRect(0, 0, next.width, next.height);
                ctx_mask.fillStyle = slide.colorScheme[slide.colorMap[slide.commonSlideData.background]];
                ctx_mask.fillRect(0, 0, mask.width, mask.height);
                slide.shapes.forEach(function (shape, idx) {
                    if (shape.type === 'shape') {
                        drawShape(slide, idx, ctx_next);
                    }
                    if (shape.type === 'pic') {
                        drawPic(slide, idx, ctx_next);
                    }
                });
                drawTransition(slide.transition, ctx_canvas, ctx_next, ctx_mask);
            } else {
                var ctx = canvas.getContext('2d');
                ctx.fillStyle = slide.colorScheme[slide.colorMap[slide.commonSlideData.background]];
                ctx.fillRect(0, 0, canvasData.cw, canvasData.ch);
                slide.commonSlideData.shapes.forEach(function (shape, idx) {
                    if (shape.type === 'shape') {
                        drawShape(slide, idx, ctx);
                    }
                    if (shape.type === 'pic') {
                        drawPic(slide, idx, ctx);
                    }
                });
            }
        }

        function drawShape(slide, idx, ctx) {
            var shape = slide.commonSlideData.shapes[idx];
            console.log(shape.id, shape.style, shape.preset);
            if(!!shape.style && !!shape.style.visibility && shape.style.visibility === 'invisible') {
                return;
            }
            {
    			var orix = shape.x, oriy = shape.y;
    			ctx.translate(emu2pixel(orix), emu2pixel(oriy));
    			shape.x = 0, shape.y = 0;
    			//=======================
        		if(!!shape.rot) {
        			var rot = shape.rot / 21600000;
        			ctx.translate(emu2pixel(shape.cx), emu2pixel(shape.cy));
        			ctx.rotate(2 * Math.PI * rot);
        		}
            	//=======================

            	if(!!shape.solidFill) {
	                ctx.fillStyle = shape.solidFill.indexOf('#')===0 ? shape.solidFill : slide.colorScheme[slide.colorMap[shape.solidFill]];
	                if(!!drawShapes[shape.preset]) {
	            		drawShapes[shape.preset](ctx, shape, emu2pixel);
		            	ctx.fill();
	                }
            	}
	            if(!!shape.gradFill) {
	            	var ang = shape.gradFill.ang;
	            	switch(ang) {
	            		case 0:
	            			var endx = shape.x + shape.cx;
	            			var endy = shape.y;
	            		break;
	            		case 5400000:
	            			var endx = shape.x;
	            			var endy = shape.y + shape.cy;
	            		break;
	            		case 10800000:
	            			var endx = shape.x - shape.cx;
	            			var endy = shape.y;
	            		break;
	            		case 16400000:
	            			var endx = shape.x;
	            			var endy = shape.y - shape.cy;
	            		break;
	            	}
	            	var grad = ctx.createLinearGradient(
	            		emu2pixel(shape.x), emu2pixel(shape.y), 
	            		emu2pixel(endx), 
	            		emu2pixel(endy)
	            	);
	            	shape.gradFill.stops.forEach(function(stop) {
	            		var color = stop.color;
	            		if(stop.color.indexOf('#') !== 0) {
	            			color = slide.colorScheme[slide.colorMap[color]];
	            		}
	        			if(!!stop.shade) {
	        				color = shade(color, stop.shade);
	        			}
	        			if(!!stop.tint) {
	        				color = tint(color);
	        			}
	        			grad.addColorStop(stop.pos/100000, color);
	            	});
	            	ctx.fillStyle = grad;
	                if(!!drawShapes[shape.preset]) {
	            		drawShapes[shape.preset](ctx, shape, emu2pixel);
		            	ctx.fill();
		            }
	            }
	            if(!!shape.line && !!shape.line.color && !!shape.line.w) {
	            	var color = shape.line.color;
	            	if(color.indexOf('#') !== 0) {
	        			color = slide.colorScheme[slide.colorMap[color]];
					}
	            	if(!!shape.line.tailEnd || !!shape.line.tailEnd) {
	            		ctx.lineJoin = 'miter';
	            	}
	            	if(!!shape.line.presetDash && shape.line.presetDash.length > 1 && shape.line.presetDash !== 'solid') {
	            		var seg = [];
	            		var pat = [];
	            		switch(shape.line.presetDash) {
	            			case 'dash':
	            			pat = [4,4];
	            			break;
	            			case 'dashDot':
	            			pat = [4,3,1,3];
	            			break;
	            			case 'dot':
	            			pat = [1,3];
	            			break;
	            			case 'lgDash':
	            			pat = [8,3];
	            			break;
	            			case 'lgDashDot':
	            			pat = [8,3,1,3];
	            			break;
	            			case 'lgDashDotDot':
	            			pat = [8,3,1,3,1,3];
	            			break;
	            			case 'sysDash':
	            			pat = [3,1];
	            			break;
	            			case 'sysDashDot':
	            			pat = [3,1,1,1];
	            			break;
	            			case 'sysDashDotDot':
	            			pat = [3,1,1,1,1,1];
	            			break;
	            			case 'sysDot':
	            			pat = [1,1];
	            			break;
	            			default:
	            			throw 'presetDash pattern not supported.';
	            			break;
	            		}
	            		pat.forEach(function(s) {
	            			seg.push(emu2pixel(shape.line.w*s));
	            		});
	            		ctx.setLineDash(seg);
	            	} else {
            			ctx.setLineDash([]);
            		}
	            	ctx.lineWidth = emu2pixel(shape.line.w);
	            	ctx.strokeStyle = color;
	            	if(!!drawShapes[shape.preset]) {
	            		drawShapes[shape.preset](ctx, shape, emu2pixel);
	            		ctx.stroke();
	            	}
	            }
            	//=======================
            	if(!!shape.rot) {
            		ctx.rotate(-2 * Math.PI * rot);
            		ctx.translate(-1 * emu2pixel(shape.cx), -1 * emu2pixel(shape.cy));
            	}
            	//=======================
            	ctx.translate(-1 * emu2pixel(orix), -1 * emu2pixel(oriy));
        		shape.x = orix;
        		shape.y = oriy;
            }
            
            //if shape outline is needed for debug
            /*ctx.strokeStyle = '#7799BB';
			ctx.strokeRect(
				emu2pixel(shape.x),
				emu2pixel(shape.y),
				emu2pixel(shape.cx),
				emu2pixel(shape.cy)
            );*/
            
            if (!!shape.textBody && !!shape.textBody.paragraphs && Array.isArray(shape.textBody.paragraphs) && shape.textBody.paragraphs.length > 0) {
                drawTextblock(shape.textBody);
            }

            function drawTextblock(block) {
                if(typeof block.lIns === 'undefined') block.lIns = 91440;
                if(typeof block.tIns === 'undefined') block.tIns = 45720;
                if(typeof block.rIns === 'undefined') block.rIns = 91440;
                if(typeof block.bIns === 'undefined') block.bIns = 45720;
                var x = shape.x + block.lIns, y = shape.y + block.tIns;
                var cx = shape.x + shape.cx - block.rIns, cy = shape.y + shape.cy - block.bIns;
                if(!!block.paragraphs && block.paragraphs.length > 0) {
	                var lineHeight1 = measureParagraph(ctx, block.paragraphs[0], false).h;
	                var textHeight = measureTextBlock(ctx, block, true).h;
                }

                if(!!block.anchor) {
                    switch(block.anchor) {
                        case 'b':
                            y = Math.round(shape.y + shape.cy - block.bIns - lineHeight1 * 0.1);
                            break;
                        case 'ctr':
                            y = Math.round(shape.y + shape.cy * 0.5 - textHeight * 0.5 + lineHeight1);
                            break;
                        default:
                        	y = Math.round(shape.y + block.tIns + lineHeight1);
                        	break;
                    }
                } else {
                	y = Math.round(shape.y + block.tIns + lineHeight1);
                }

                var txt = '';
                if(!!block.paragraphs) {
                	block.paragraphs.forEach(function(paragraph) {
                		if(!!paragraph.runs) {
                			paragraph.runs.forEach(function(run) {
                				if(run.type === 'r' && !!run.text) {
                					txt += run.text;
                				}
                			})
                		}
                	})
                }

                var linenum = 0;
                var textOffY = y;
                block.paragraphs.forEach(function (paragraph, index) {
                	if(!!paragraph.algn) {
                		var align = paragraph.algn;
                	} else {
                		align = 'l';
                	}
                    var para_line_num = 0;
                    var lineSpec = measureBreakingParagraph(ctx, paragraph);
                	switch(align) {
                		case 'r':
                			var textOffX = shape.x + shape.cx - (!!paragraph.marR?paragraph.marR:0) - block.rIns - lineSpec[para_line_num].w;
                		break;
                		case 'ctr':
                			var textOffX = shape.x + shape.cx / 2 - lineSpec[para_line_num].w / 2;
                		break;
                		default:
		                    var textOffX = x + (!!paragraph.marL?paragraph.marL:0) + (!!paragraph.indent?paragraph.indent:0);
                		break;
                	}
                    var buOffX = 0;
                    if(!!paragraph.runs) {
                        var tl = paragraph.runs.reduce(function(pre, cur) {
                            if(cur.type === 'r' && !!cur.text) {
                                pre += cur.text.length;
                            }
                            return pre;
                        }, 0);
                        if(!!paragraph.buFont && !!paragraph.buChar && !!paragraph.buClr && tl > 0) {
                            buOffX = drawText(ctx, textOffX, textOffY, paragraph.buFont, paragraph.buClr, paragraph.defRPr.sz, paragraph.buChar+' ');
                            textOffX += buOffX + paragraph.spcBef;
                        }
                        if(!!paragraph.buAutoNum && tl > 0) {
                        	var runs = paragraph.runs.filter(function(z) {return z.type === 'r' && !!z.text});
                        	if(runs.length > 0) {
                        		var run = runs[0];
                                if('undefined' === typeof run.ea || run.ea === null) run.ea = '+mj-ea';
                                if('undefined' === typeof run.latin || run.latin === null) run.latin = '+mj-lt';
                                if('undefined' === typeof run.lang || run.lang === null) run.lang = 'zh-TW';
                                
                                if(run.ea !== '+mj-ea' && run.ea !== '+mn-ea') {
                                    var buFace = run.ea;
                                } else {
                                    var tmp = fontmap[run[langmap[run.lang]]];
                                    if(typeof tmp === 'string') {
                                        var buFace = tmp;
                                    } else {
                                        var buFace = tmp[scriptmap[run.lang]];
                                    }
                                }

                                switch(paragraph.buAutoNum) {
                                	case 'circleNumWdWhitePlain':
                                		if(linenum<11) {
                                			buChar = String.fromCharCode(0x2460 + linenum);
                                		} else {
                                			buChar = linenum;
                                		}
                                	break;
                                }

	                            buOffX = drawText(ctx, textOffX, textOffY, buFace, (!!run.solidFill?run.solidFill:'tx1'), !!run.sz?run.sz:1800, buChar + ' ');
	                            textOffX += buOffX;
                        	}
                        }
                        paragraph.runs.forEach(function(run) {
                            if(run.type === 'r' && !!run.text) {
                                if('undefined' === typeof run.ea || run.ea === null) run.ea = '+mj-ea';
                                if('undefined' === typeof run.latin || run.latin === null) run.latin = '+mj-lt';
                                if('undefined' === typeof run.lang || run.lang === null) run.lang = 'zh-TW';
                                
                                if(run.ea !== '+mj-ea' && run.ea !== '+mn-ea') {
                                    var face = run.ea;
                                } else {
                                    var tmp = fontmap[run[langmap[run.lang]]];
                                    if(typeof tmp === 'string') {
                                        var face = tmp;
                                    } else {
                                        var face = tmp[scriptmap[run.lang]];
                                    }
                                }

                                for(var i=0; i<run.text.length; i++) {
                                    textOffX += drawText(ctx, textOffX, textOffY, face, (!!run.solidFill?run.solidFill:'tx2'), !!run.sz?run.sz:1800, run.text[i], run.b, run.i);
                                }
                            }
                            if(run.type === 'br') {
                                textOffY += lineSpec[para_line_num].h;
                                para_line_num++;
                                switch(align) {
                                	case 'r':
                                	textOffX = shape.x + shape.cx - (!!paragraph.marR?paragraph.marR:0) - block.rIns - lineSpec[para_line_num].w;
                                	break;
                                	case 'ctr':
                                	textOffX = shape.x + shape.cx / 2 - lineSpec[para_line_num].w / 2;
                                	break;
                                	default:
	                                textOffX = x + (!!paragraph.marL?paragraph.marL:0) + (!!paragraph.indent?paragraph.indent:0) + buOffX;
                                	break;
                                }
                            }
                            if(run.type === 'end') {
                            	//console.log('run end');
                            }
                        });
                    }
                    textOffY += lineSpec[para_line_num].h;
                    linenum++;
                });

                function drawText(ctx, hpos, vpos, font, color, size, str, b, i) {
                	var localface = '';
                	if(!!b) localface += ' 900 ';
                	if(!!i) localface += ' italic ';
                	localface += pt2pixel(size, presentationData.cw, canvasData.cw) + 'px ' + font;
                    ctx.font = localface.trim();
                    var clr = color.indexOf('#') === 0 ? color : slide.colorScheme[slide.colorMap[color]];
                    ctx.fillStyle = clr;
                    //ctx.textBaseline = 'ideographic';
                    ctx.textBaseline = '';
                    ctx.fillText(str, emu2pixel(hpos), emu2pixel(vpos));
                    var ret = pixel2emu(ctx.measureText(str).width, presentationData.cw, canvasData.cw);
                    ctx.font = '';
                    ctx.fillStyle = '';
                    return ret;
                }
            }
        }

        function measureTextBlock(ctx, block, wrap) {
            if(typeof block.lIns === 'undefined') block.lIns = 91440;
            if(typeof block.tIns === 'undefined') block.tIns = 45720;
            if(typeof block.rIns === 'undefined') block.rIns = 91440;
            if(typeof block.bIns === 'undefined') block.bIns = 45720;
        	var tmp = block.paragraphs.reduce(function(pre, cur) {
        		var tmp = measureParagraph(ctx, cur, wrap);
        		pre.w += tmp.w;
        		pre.h += tmp.h;
        		return pre;
        	}, {w: 0, h: 0});
        	tmp.w += block.lIns + block.rIns;
        	tmp.h += block.tIns + block.bIns;
        	return tmp;
        }

        function measureBreakingParagraph(ctx, paragraph) {
        	var ret = {w: 0, h: 0};
    		var lh = paragraph.runs.reduce(function(pre, cur) {
    			if(cur.type === 'r' && cur.sz > pre) pre = cur.sz;
    			return pre;
    		}, 1800);
			var lineHeight = Math.round(pixel2emu(pt2pixel(lh, presentationData.cw, canvasData.cw) * 1.05));
    		ret.h = lineHeight;
    		var tmpwidth = [];
    		paragraph.runs.forEach(function(run) {
                if('undefined' === typeof run.ea || run.ea === null) run.ea = '+mj-ea';
                if('undefined' === typeof run.latin || run.latin === null) run.latin = '+mj-lt';
                if('undefined' === typeof run.lang || run.lang === null) run.lang = 'zh-TW';
                
                if(run.ea !== '+mj-ea' && run.ea !== '+mn-ea') {
                    var face = run.ea;
                } else {
                    var tmp = fontmap[run[langmap[run.lang]]];
                    if(typeof tmp === 'string') {
                        var face = tmp;
                    } else {
                        var face = tmp[scriptmap[run.lang]];
                    }
                }
    			if(run.type === 'br') {
    				tmpwidth.push(ret.w);
    				ret.w = 0;
    			}
    			if(run.type === 'r') {
    				if(!!run.text && run.text.length > 0) {
        				ret.w += measureText(ctx, run.text, face, !!run.sz?run.sz:1800, run.b, run.i);
    				}
    			}
    		});
			tmpwidth.push(ret.w);
			return tmpwidth.reduce(function(pre, cur) {
				pre.push({w: cur, h: ret.h});
				return pre;
			}, []);
        }

        function measureParagraph(ctx, paragraph, wrap) {
        	var ret = {w: 0, h: 0};
    		var lh = paragraph.runs.reduce(function(pre, cur) {
    			if(cur.type === 'r' && cur.sz > pre) pre = cur.sz;
    			return pre;
    		}, 1800);
    		var lineHeight = Math.round(pixel2emu(pt2pixel(lh, presentationData.cw, canvasData.cw) * 1.05, presentationData.cw, canvasData.cw));
        	if(wrap) {
        		ret.h = lineHeight;
        		var tmpwidth = [];
        		paragraph.runs.forEach(function(run) {
                    if('undefined' === typeof run.ea || run.ea === null) run.ea = '+mj-ea';
                    if('undefined' === typeof run.latin || run.latin === null) run.latin = '+mj-lt';
                    if('undefined' === typeof run.lang || run.lang === null) run.lang = 'zh-TW';
                    
                    if(run.ea !== '+mj-ea' && run.ea !== '+mn-ea') {
                        var face = run.ea;
                    } else {
                        var tmp = fontmap[run[langmap[run.lang]]];
                        if(typeof tmp === 'string') {
                            var face = tmp;
                        } else {
                            var face = tmp[scriptmap[run.lang]];
                        }
                    }
        			if(run.type === 'br') {
        				ret.h += lineHeight;
        				tmpwidth.push(ret.w);
        				ret.w = 0;
        			}
        			if(run.type === 'r') {
        				if(!!run.text && run.text.length > 0) {
            				ret.w += measureText(ctx, run.text, face, !!run.sz?run.sz:1800, run.b, run.i);
        				}
        			}
        		});
				if(tmpwidth.length > 0) {
					ret.w = tmpwidth[0];
				}
        	} else {
        		ret.h = lineHeight;
        		paragraph.runs.forEach(function(run) {
                    if('undefined' === typeof run.ea || run.ea === null) run.ea = '+mj-ea';
                    if('undefined' === typeof run.latin || run.latin === null) run.latin = '+mj-lt';
                    if('undefined' === typeof run.lang || run.lang === null) run.lang = 'zh-TW';
                    
                    if(run.ea !== '+mj-ea' && run.ea !== '+mn-ea') {
                        var face = run.ea;
                    } else {
                        var tmp = fontmap[run[langmap[run.lang]]];
                        if(typeof tmp === 'string') {
                            var face = tmp;
                        } else {
                            var face = tmp[scriptmap[run.lang]];
                        }
                    }
        			if(run.type === 'r') {
        				if(!!run.text && run.text.length > 0) {
            				ret.w += measureText(ctx, run.text, face, !!run.sz?run.sz:1800, run.b, run.i);
        				}
        			}
        		});
        	}
        	ret.w += (!!paragraph.marL?paragraph.marL:0) + (!!paragraph.marR?paragraph.marR:0);
			return ret;
        }

        function measureText(ctx, str, font, size, b, i) {
			var localface = '';
			var ret = 0;
        	if(!!b) localface += ' 900 ';
        	if(!!i) localface += ' italic ';
        	localface += pt2pixel(size, presentationData.cw, canvasData.cw) + 'px ' + font;
            ctx.font = localface.trim();
            var tmp = ctx.measureText(str).width;
            ret += pixel2emu(tmp, presentationData.cw, canvasData.cw);
            return ret;
        }

        function drawPic(slide, idx, ctx) {
            var pic = slide.commonSlideData.shapes[idx];
            var img = media[pic.blip.embed];
        	if(typeof pic.blip.srcRect === 'undefined') pic.blip.srcRect = {l:0, r:0, t:0, b:0};
            var picx = img.width, picy = img.height;
            var l = pic.blip.srcRect.l / 100000, r = pic.blip.srcRect.r / 100000, t = pic.blip.srcRect.t / 100000, b = pic.blip.srcRect.b / 100000;
            var offx = pic.x, offy = pic.y;
            var cx = pic.cx, cy = pic.cy;

            var sx = Math.round(picx * l), sy = Math.round(picy * t);
            var sw = Math.round(picx - picx * (l + r)), sh = Math.round(picy - picy * (t + b));
            var dx = emu2pixel(offx), dy = emu2pixel(offy);
            var dw = emu2pixel(cx), dh = emu2pixel(cy);
            ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
        }

        function drawTransition(transition, target, next, mask) {
            var start = null;
            requestAnimationFrame(transitionAnimate);
            function transitionAnimate(t) {
                if (start === null) {
                    start = t;
                    requestAnimationFrame(transitionAnimate);
                } else {
                    var progress = (t - start) / transition.duration;
                    mask.fillStyle = '#FFFFFF';
                    mask.fillRect(0, 0, canvasData.canvas.width, canvasData.canvas.height);
                    drawTransitionPattern(transition, mask, progress);
                    var x = 0, y = 0;
                    var maskImg = mask.getImageData(0, 0, canvasData.cw, canvasData.ch);
                    var nextImg = next.getImageData(0, 0, canvasData.cw, canvasData.ch);
                    var targetImg = target.getImageData(0, 0, canvasData.cw, canvasData.ch);
                    var output = target.createImageData(targetImg);
                    for (var i = 0; i < targetImg.data.length; i += 4) {
                        if (maskImg.data[i] == 0 && maskImg.data[i + 1] == 0 && maskImg.data[i + 2] == 0) {
                            output.data[i] = nextImg.data[i];
                            output.data[i + 1] = nextImg.data[i + 1];
                            output.data[i + 2] = nextImg.data[i + 2];
                            output.data[i + 3] = 255;
                        } else {
                            output.data[i] = targetImg.data[i];
                            output.data[i + 1] = targetImg.data[i + 1];
                            output.data[i + 2] = targetImg.data[i + 2];
                            output.data[i + 3] = 255;
                        }
                    }
                    target.putImageData(output, 0, 0);
                    if (t - start < transition.duration) {
                        requestAnimationFrame(transitionAnimate);
                    }
                }
            }
        }

        function drawTransitionPattern(transition, mask, progress) {
            switch (transition.type) {
                case 'comb':
                    var num = 8;
                    var start = 0;
                    var side = 0;
                    if (transition.dir === 'horz') {
                        var bh = Math.round(canvasData.ch / num);
                        while (start < canvasData.ch) {
                            mask.fillStyle = '#000000';
                            if (side % 2 === 0) {
                                mask.fillRect(0, start, Math.round(progress * canvasData.cw), bh);
                            } else {
                                var l = Math.round(canvasData.cw * (1 - progress));
                                mask.fillRect(Math.round(canvasData.cw * (1 - progress)), start, canvasData.cw - l, bh);
                            }
                            start += bh;
                            side++;
                        }
                    } else {
                        var bw = Math.round(canvasData.cw / num);
                        while (start < canvasData.cw) {
                            mask.fillStyle = '#000000';
                            if (side % 2 === 0) {
                                mask.fillRect(start, 0, bw, Math.round(progress * canvasData.ch));
                            } else {
                                var t = Math.round(canvasData.ch * (1 - progress));
                                mask.fillRect(start, Math.round(canvasData.ch * (1 - progress)), bw, canvasData.ch - t);
                            }
                            start += bw;
                            side++;
                        }
                    }
                    break;
            }
        }

        function pt2pixel(sz) {
        	var screenw = presentationData.cw, canvasw = canvasData.cw;
            return sz * 914400 * canvasw / 100 / 72 / screenw;
        }

        function emu2pixel(l) {
        	var screenw = presentationData.cw, canvasw = canvasData.cw;
            return l * canvasw / screenw;
        }

        function pixel2emu(l) {
        	var screenw = presentationData.cw, canvasw = canvasData.cw;
            return l * screenw / canvasw;
        }

        function calculateCanvasWidth(vzw, vzh) {
            if (vzh / 3 * 4 < vzw) {
                return {w: Math.round((vzh - 20) * 4 / 3), h: vzh - 20};
            } else {
                return {w: vzw - Math.round(20 * 4 / 3), h: Math.round(vzw * 3 / 4) - 20};
            }
        }

        function define_quadratic_bezier(x0, y0, x1, y1, x2, y2) {
            return function (t) {
                if (t < 0 || t > 1) throw "[define_quadratic_bezier] t must between 0 and 1.";
                var px = Math.pow(1 - t, 2) * x0 + 2 * t * (1 - t) * x1 + Math.pow(t, 2) * x2;
                var py = Math.pow(1 - t, 2) * y0 + 2 * t * (1 - t) * y1 + Math.pow(t, 2) * y2;
                return [px, py];
            };
        }

        //this easing is from jquery's swing
        function easing(p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        }
        
        function wait(f, n) {
        	var count = f.length;
        	f.forEach(function(g) {
        		g(done);
        	});
        	function done() {
        		count--;
        		if(count <= 0) {
        			n();
        		}
        	}
        }

        function shade(color, fact) {
        	color = color.trim();
        	fact = fact / 100000;
        	if(color.indexOf('#') === 0) {
        		var c = color.substr(1);
        	} else {
        		var c = color;
        	}
    		var r = parseInt(c.substr(0, 2), 16);
    		var g = parseInt(c.substr(2, 2), 16);
    		var b = parseInt(c.substr(4, 2), 16);
    		r = Math.round(r * (1 - fact<1?fact:fact/100000));
    		g = Math.round(g * (1 - fact<1?fact:fact/100000));
    		b = Math.round(b * (1 - fact<1?fact:fact/100000));
    		return '#' + padHex(r, 2).toUpperCase() + padHex(g, 2).toUpperCase() + padHex(b, 2).toUpperCase();
        }

        function tint(color, fact) {
        	color = color.trim();
        	if(color.indexOf('#') === 0) {
        		var c = color.substr(1);
        	} else {
        		var c = color;
        	}
    		var r = parseInt(c.substr(0, 2), 16);
    		var g = parseInt(c.substr(2, 2), 16);
    		var b = parseInt(c.substr(4, 2), 16);
    		r = Math.round(r + (255 - r) * fact<1?fact:fact/100000);
    		g = Math.round(g + (255 - g) * fact<1?fact:fact/100000);
    		b = Math.round(b + (255 - b) * fact<1?fact:fact/100000);
    		return '#' + padHex(r, 2).toUpperCase() + padHex(g, 2).toUpperCase() + padHex(b, 2).toUpperCase();
        }

        function padHex(input, l) {
        	if(typeof input !== 'string') {
        		input = input.toString(16);
        	}
        	var ret = input;
        	for(var i=0; i<l-input.length; i++) {
        		ret = '0' + ret;
        	}
        	return ret;
        }
    });
</script>
</body>
</html>
