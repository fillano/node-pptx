<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <!--<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css" type="text/css" />-->
    <style>
        .layout {
            display: block;
            margin: 0 0 0 0;
            padding: 0 0 0 0;
            text-align: center;
        }
        #canvas {
            display:inline-block;
            background-color: white;
            position: relative;
        }
        #buffer {
            display: none;
            position: absolute;
            left: -150000px;
            top: -150000px;
        }
        #panel {
            display: block;
            position: relative;
            padding: 0 0 0 0;
            margin: 0 0 0 0;
            text-align: center;
        }
        #controls {
            display: block;
            position: absolute;
            width: 100%;
            text-align: center;
        }
        .steps_canvas {
            display: none;
            position: absolute;
            left: -100000px;
            top: -100000px;
            /*background-color: rgba(0, 0, 0, 0);*/
        }

        .steps_canvas_hidden {
            display: none;
            position: absolute;
            left: -100000px;
            top: -100000px;
            /*background-color: rgba(0, 0, 0, 0);*/
        }
    </style>
</head>
<body style="background-color: #000;text-align: center;padding:0 0 0 0; margin: 0 0 0 0">
<div class="layout">
    <div id="panel"><canvas id="canvas" width="800" height="600"></canvas><canvas id="buffer" width="800" height="600"></canvas></div>
</div>
<div id="controls">
    <button id="step1">上一步</button>
    <button id="step2">下一步</button>
    <button id="fullscreen">全螢幕</button>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
<script src="drawshapes.js"></script>
<script src="main.js"></script>
<script>
    $(function () {
        var canvas = $('#canvas')[0];
        var buffer = $('#buffer')[0];
        var stepsCanvas = [];

        var presentationData = {};

        var canvasData = {};

        var slideList = [];
        var anim_lock = false;

        var currentSlide = 0;
        var currentStep = 0;
        var steps = [];
        var stepsCache = [];
        var builds = [];
        var stepsCanvasCache = [];
        var slide = {};

        var media = {};

        var langmap = {
            "zh-TW": "ea",
            "zh-CN": "ea",
            "en-US": "latin",
            "en-GB": "latin"
        };

        var scriptmap = {
            "zh-TW": 'Hant',
            "zh-CN": 'Hans'
        };
        var fontmap = {};
        var touchX1 = 0;
        var touchX2 = 0;

        presentationInit(data);

        $('#step1').click(function() {
            goPrev();
        });
        $('#step2').click(function() {
            goNext();
        });
        document.body.addEventListener('touchstart', function(e) {
            touchX1 = e.pageX;
        }, false);
        document.body.addEventListener('touchend', function(e) {
            touchX2 = e.pageX;
            if(touchX2>touchX1 && touchX2-touchX1 > 20) {
                goNext();
            }
            if(touchX1>touchX2 && touchX1-touchX2 > 20) {
                goPrev();
            }
        }, false);
        window.addEventListener('resize', function(e) {
            presentationInit(data);
        });

        function goNext() {
            if(!anim_lock) {
                if(currentStep < steps.length) {
                    currentStep++;
                    stepExecuter(steps[currentStep-1]);
                } else {
                    if(currentSlide < slideList.length-1) {
                        if(stepsCache.length <= currentSlide + 1) {
                            stepsCache[currentSlide] = steps;
                            stepsCanvasCache[currentSlide] = stepsCanvas;
                        }
                        setTimeout(function() {
                            data.slides[slideList[currentSlide-1].rid].commonSlideData.shapes.forEach(function(shape) {
                                document.getElementById('panel').removeChild(shape.canvas);
                                shape.canvas = null;
                            });
                        }, 0);
                        currentSlide++;
                        slide = data.slides[slideList[currentSlide].rid];
                        currentStep = 0;
                        stepsCanvas = [];
                        slideInit(data, currentSlide);
                    }
                }
            }
        }

        function goPrev() {
            if(!anim_lock) {
                if(currentStep === 0) {
                    currentSlide--;
                    setTimeout(function() {
                        data.slides[slideList[currentSlide+1].rid].commonSlideData.shapes.forEach(function(shape) {
                            document.getElementById('panel').removeChild(shape.canvas);
                            shape.canvas = null;
                        });
                    }, 0);
                }
                currentStep = 0;
                slide = data.slides[slideList[currentSlide].rid];
                slideInit(data, currentSlide);
            }
            /*if(!anim_lock) {
                if(currentStep > 0) {
                    currentStep--;
                    canvas.getContext('2d').putImageData(stepsCanvas[currentStep], 0, 0);
                } else {
                    if(currentSlide > 0) {
                        currentSlide--;
                        slide = data.slides[slideList[currentSlide].rid];
                        stepsCanvas = stepsCanvasCache[currentSlide];
                        steps = stepsCache[currentSlide];
                        currentStep = stepsCanvas.length>0?stepsCanvas.length-1:0;
                        canvas.getContext('2d').putImageData(stepsCanvas[currentStep], 0, 0);
                    }
                }
            }*/
        }

        function hideCanvas() {
            stepsCanvas[currentStep].className = 'steps_canvas_hide';
        }

        $('#fullscreen').click(function() {
            (function() {
                if(!!document.body.webkitRequestFullscreen) {
                    document.body.webkitRequestFullscreen();
                    return;
                }
                if(!!document.body.mozRequestFullScreen) {
                    document.body.mozRequestFullScreen();
                    return;
                }
                if(!!document.body.msRequestFullscreen) {
                    document.body.msRequestFullscreen();
                    return;
                }
                if(!!document.body.requestFullscreen) {
                    document.body.requestFullscreen();
                }
            })();
            slideInit(data, currentSlide);
        });

        $(document).on('keyup', function(e) {
            if(e.keyCode === 39 || e.keyCode === 32) {
                goNext();
            }
            if(e.keyCode === 37) {
                goPrev();
            }
        });

        function canvasInit() {
            var vzw = document.documentElement.clientWidth;
            var vzh = document.documentElement.clientHeight;
            var _canvasd = calculateCanvasWidth(vzw, vzh);
            canvasData.cw = _canvasd.w;
            canvasData.ch = _canvasd.h;
            canvas.width = _canvasd.w;
            canvas.height = _canvasd.h;
            buffer.width = _canvasd.w;
            buffer.height = _canvasd.h;
            document.getElementById('controls').style.top = vzh - 20 + 'px';
        }

        function presentationInit(data) {
            canvasInit();

            presentationData.cw = parseInt(data.presentation.slideSize.cx, 10);
            presentationData.ch = parseInt(data.presentation.slideSize.cy, 10);
            slideList = data.presentation.slideIdList.reduce(function(pre, cur) {
                pre.push({rid:cur.rid, target:cur.target});
                return pre;
            }, []);
            slideInit(data, currentSlide);
        }

        function slideInit(data, idx) {
            var layoutTarget = Object.keys(data.relations[slideList[idx].target]).filter(function(z) {
                return z.search(/^ppt\/slideLayouts\/slideLayout[0-9]+\.xml$/) > -1;
            })[0];
            var masterTarget = Object.keys(data.relations[layoutTarget]).filter(function(z) {
                return z.search(/^ppt\/slideMasters\/slideMaster[0-9]+\.xml$/) > -1;
            })[0];
            var themeTarget = Object.keys(data.relations[masterTarget]).filter(function(z) {
                return z.search(/^ppt\/theme\/theme[0-9]+\.xml$/) > -1;
            })[0];
            fontmap = {
                "+mj-lt": data.themes[themeTarget].fontScheme.majorFont.latin,
                "+mj-ea": data.themes[themeTarget].fontScheme.majorFont.fonts,
                "+mn-lt": data.themes[themeTarget].fontScheme.minorFont.latin,
                "+mn-ea": data.themes[themeTarget].fontScheme.minorFont.fonts
            };
            media = {};

            slide = data.slides[slideList[idx].rid];
            wait(slide.commonSlideData.shapes.reduce(function(pre, cur, index) {
                if(!cur.canvas) {
                    cur.canvas = createCanvas(index === 0);
                    cur.shapeIndex = index;
                    cur.resize = false;
                } else {
                    if(cur.canvas.width !== canvasData.cw) {
                        document.getElementById('panel').removeChild(cur.canvas);
                        cur.canvas = createCanvas(index === 0);
                        cur.resize = true;
                    } else {
                        if(!!cur.orig) {
                            Object.keys(cur.orig).forEach(function(k) {
                                cur[k] = cur.orig[k];
                            });
                        }
                        clearCanvas(cur.canvas);
                        cur.resize = false;
                    }
                }
                if(cur.type === 'pic') pre.push(cur.blip.embed);
                return pre;
            }, []).reduce(function(pre, cur) {
                pre.push(preload(cur));
                return pre;
            }, []), function() {
                steps = [];
                builds = [];
                timingInit(slide);
                drawSlide(slide);
            });
            function preload(url) {
                return function(done) {
                    var img = new Image();
                    img.src = url;
                    img.onload = function () {
                        media[url] = img;
                        done();
                    };
                }
            }
        }

        function timingInit(slide) {
            var timing = slide.timing;
            steps = stepBuilder(timing);
            if(!!timing.bldLst) {
                builds = timing.bldLst;
            }
            stepsCanvas = [];
            steps.forEach(function(step) {
                stepWalker(step, slide.commonSlideData.shapes, function(shape) {
                    stepsCanvas.push(shape.id);
                    if(!shape.resize) {
                        if(!!shape.style) {
                            shape.style.visibility = 'invisible';
                        } else {
                            shape.style = {visibility: 'invisible'};
                        }
                    }
                });
            });
            builds.forEach(function(bld) {
                slide.commonSlideData.shapes.forEach(function(shape) {
                    if(parseInt(shape.id, 10) === parseInt(bld.spid, 10)) {
                        if(!!shape.style) {
                            //shape.style.visibility = 'invisible';
                        } else {
                            //shape.style = {visibility: 'invisible'};
                        }
                    }
                });
            });
        }

        function stepWalker(step, shapes, cb) {
            if(step.name === 'p:set') {
                if(!!step.attrNameLst && step.attrNameLst.length > 0) {
                    var e = step.attrNameLst.filter(function(x) {return x.val === 'style.visibility' && x.name === 'p:attrName'});
                    if(e.length > 0) {
                        var target = step.tgtEl;
                        shapes.forEach(function(shape) {
                            if(parseInt(shape.id, 10) === parseInt(target, 10)) {
                                cb(shape);
                            }
                        });
                    }
                }
            }
            if(!!step.childTnLst) {
                step.childTnLst.forEach(function(next) {
                   stepWalker(next, shapes, cb);
                });
            }
        }

        function stepBuilder(timing) {
            var ret = [];
            timing.tnLst.forEach(function(tn) {
                if(tn.nodeType === 'tmRoot' && !!tn.childTnLst) {
                    tn.childTnLst.forEach(function(tn) {
                        if(tn.nodeType === 'mainSeq' && !!tn.childTnLst) {
                           tn.childTnLst.forEach(function(tn) {
                               if(tn.nodeType === 'clickPar') {
                                   ret.push(tn);
                               }
                           });
                        }
                    });
                }
            });
            return ret;
        }

        function drawSlide(slide) {
            slide.commonSlideData.shapes.forEach(function (shape) {
                if (shape.type === 'shape') {
                    drawShape(shape);
                }
                if (shape.type === 'pic') {
                    drawPic(shape);
                }
            });
            render(slide, canvas);
        }

        function drawShape(shape) {
            //var shape = slide.commonSlideData.shapes[idx];
            var ctx = shape.canvas.getContext('2d');
            if(shape.shapeIndex === 0) {
                ctx.fillStyle = slide.colorScheme[slide.colorMap[slide.commonSlideData.background]];
                ctx.fillRect(0, 0, canvasData.cw, canvasData.ch);
            }
            if(!!shape.style && !!shape.style.visibility && shape.style.visibility === 'invisible') {
                return;
            }
            {
    			var orix = shape.x, oriy = shape.y;
    			ctx.translate(emu2pixel(orix), emu2pixel(oriy));
    			shape.x = 0, shape.y = 0;
    			//=======================
        		if(!!shape.rot) {
        			var rot = shape.rot / 21600000;
        			ctx.translate(emu2pixel(shape.cx), emu2pixel(shape.cy));
        			ctx.rotate(2 * Math.PI * rot);
        		}
            	//=======================

            	if(!!shape.solidFill) {
	                ctx.fillStyle = shape.solidFill.indexOf('#')===0 ? shape.solidFill : slide.colorScheme[slide.colorMap[shape.solidFill]];
	                if(!!drawShapes[shape.preset]) {
	            		drawShapes[shape.preset](ctx, shape, emu2pixel);
		            	ctx.fill();
	                }
            	}
	            if(!!shape.gradFill) {
	            	var ang = shape.gradFill.ang;
	            	switch(ang) {
	            		case 0:
	            			var endx = shape.x + shape.cx;
	            			var endy = shape.y;
	            		break;
	            		case 5400000:
	            			var endx = shape.x;
	            			var endy = shape.y + shape.cy;
	            		break;
	            		case 10800000:
	            			var endx = shape.x - shape.cx;
	            			var endy = shape.y;
	            		break;
	            		case 16400000:
	            			var endx = shape.x;
	            			var endy = shape.y - shape.cy;
	            		break;
	            	}
	            	var grad = ctx.createLinearGradient(
	            		emu2pixel(shape.x), emu2pixel(shape.y), 
	            		emu2pixel(endx), 
	            		emu2pixel(endy)
	            	);
	            	shape.gradFill.stops.forEach(function(stop) {
	            		var color = stop.color;
	            		if(stop.color.indexOf('#') !== 0) {
	            			color = slide.colorScheme[slide.colorMap[color]];
	            		}
	        			if(!!stop.shade) {
	        				color = shade(color, stop.shade);
	        			}
	        			if(!!stop.tint) {
	        				color = tint(color);
	        			}
	        			grad.addColorStop(stop.pos/100000, color);
	            	});
	            	ctx.fillStyle = grad;
	                if(!!drawShapes[shape.preset]) {
	            		drawShapes[shape.preset](ctx, shape, emu2pixel);
		            	ctx.fill();
		            }
	            }
	            if(!!shape.line && !!shape.line.color && !!shape.line.w) {
	            	var color = shape.line.color;
	            	if(color.indexOf('#') !== 0) {
	        			color = slide.colorScheme[slide.colorMap[color]];
					}
	            	if(!!shape.line.tailEnd || !!shape.line.tailEnd) {
	            		ctx.lineJoin = 'miter';
	            	}
	            	if(!!shape.line.presetDash && shape.line.presetDash.length > 1 && shape.line.presetDash !== 'solid') {
	            		var seg = [];
	            		var pat = [];
	            		switch(shape.line.presetDash) {
	            			case 'dash':
	            			pat = [4,4];
	            			break;
	            			case 'dashDot':
	            			pat = [4,3,1,3];
	            			break;
	            			case 'dot':
	            			pat = [1,3];
	            			break;
	            			case 'lgDash':
	            			pat = [8,3];
	            			break;
	            			case 'lgDashDot':
	            			pat = [8,3,1,3];
	            			break;
	            			case 'lgDashDotDot':
	            			pat = [8,3,1,3,1,3];
	            			break;
	            			case 'sysDash':
	            			pat = [3,1];
	            			break;
	            			case 'sysDashDot':
	            			pat = [3,1,1,1];
	            			break;
	            			case 'sysDashDotDot':
	            			pat = [3,1,1,1,1,1];
	            			break;
	            			case 'sysDot':
	            			pat = [1,1];
	            			break;
	            			default:
	            			throw new Error('presetDash pattern not supported.');
	            			break;
	            		}
	            		pat.forEach(function(s) {
	            			seg.push(emu2pixel(shape.line.w*s));
	            		});
	            		ctx.setLineDash(seg);
	            	} else {
            			ctx.setLineDash([]);
            		}
	            	ctx.lineWidth = emu2pixel(shape.line.w);
	            	ctx.strokeStyle = color;
	            	if(!!drawShapes[shape.preset]) {
	            		drawShapes[shape.preset](ctx, shape, emu2pixel);
	            		ctx.stroke();
	            	}
	            }
            	//=======================
            	if(!!shape.rot) {
            		ctx.rotate(-2 * Math.PI * rot);
            		ctx.translate(-1 * emu2pixel(shape.cx), -1 * emu2pixel(shape.cy));
            	}
            	//=======================
            	ctx.translate(-1 * emu2pixel(orix), -1 * emu2pixel(oriy));
        		shape.x = orix;
        		shape.y = oriy;
            }
            
            //if shape outline is needed for debug
            /*ctx.strokeStyle = '#7799BB';
			ctx.strokeRect(
				emu2pixel(shape.x),
				emu2pixel(shape.y),
				emu2pixel(shape.cx),
				emu2pixel(shape.cy)
            );*/
            
            if (!!shape.textBody && !!shape.textBody.paragraphs && Array.isArray(shape.textBody.paragraphs) && shape.textBody.paragraphs.length > 0) {
                drawTextblock(shape.textBody);
            }

            //shape.canvas.className = 'steps_canvas';

            function drawTextblock(block) {
                if(typeof block.lIns === 'undefined') block.lIns = 91440;
                if(typeof block.tIns === 'undefined') block.tIns = 45720;
                if(typeof block.rIns === 'undefined') block.rIns = 91440;
                if(typeof block.bIns === 'undefined') block.bIns = 45720;
                var x = shape.x + block.lIns, y = shape.y + block.tIns;
                var cx = shape.x + shape.cx - block.rIns, cy = shape.y + shape.cy - block.bIns;
                if(!!block.paragraphs && block.paragraphs.length > 0) {
	                var lineHeight1 = measureParagraph(ctx, block.paragraphs[0], false).h;
	                var textHeight = measureTextBlock(ctx, block, true).h;
                }

                if(!!block.anchor) {
                    switch(block.anchor) {
                        case 'b':
                            y = Math.round(shape.y + shape.cy - block.bIns - lineHeight1 * 0.1);
                            break;
                        case 'ctr':
                            y = Math.round(shape.y + shape.cy * 0.5 - textHeight * 0.5 + lineHeight1);
                            break;
                        default:
                        	y = Math.round(shape.y + block.tIns + lineHeight1);
                        	break;
                    }
                } else {
                	y = Math.round(shape.y + block.tIns + lineHeight1);
                }

                var txt = '';
                if(!!block.paragraphs) {
                	block.paragraphs.forEach(function(paragraph) {
                		if(!!paragraph.runs) {
                			paragraph.runs.forEach(function(run) {
                				if(run.type === 'r' && !!run.text) {
                					txt += run.text;
                				}
                			})
                		}
                	})
                }

                var linenum = 0;
                var textOffY = y;
                block.paragraphs.forEach(function (paragraph, index) {
                	if(!!paragraph.algn) {
                		var align = paragraph.algn;
                	} else {
                		align = 'l';
                	}
                    var para_line_num = 0;
                    var lineSpec = measureBreakingParagraph(ctx, paragraph);
                	switch(align) {
                		case 'r':
                			var textOffX = shape.x + shape.cx - (!!paragraph.marR?paragraph.marR:0) - block.rIns - lineSpec[para_line_num].w;
                		break;
                		case 'ctr':
                			var textOffX = shape.x + shape.cx / 2 - lineSpec[para_line_num].w / 2;
                		break;
                		default:
		                    var textOffX = x + (!!paragraph.marL?paragraph.marL:0) + (!!paragraph.indent?paragraph.indent:0);
                		break;
                	}
                    var buOffX = 0;
                    if(!!paragraph.runs) {
                        var tl = paragraph.runs.reduce(function(pre, cur) {
                            if(cur.type === 'r' && !!cur.text) {
                                pre += cur.text.length;
                            }
                            return pre;
                        }, 0);
                        if(!!paragraph.buFont && !!paragraph.buChar && !!paragraph.buClr && tl > 0) {
                            buOffX = drawText(ctx, textOffX, textOffY, paragraph.buFont, paragraph.buClr, paragraph.defRPr.sz, paragraph.buChar+' ');
                            textOffX += buOffX + paragraph.spcBef;
                        }
                        if(!!paragraph.buAutoNum && tl > 0) {
                        	var runs = paragraph.runs.filter(function(z) {return z.type === 'r' && !!z.text});
                        	if(runs.length > 0) {
                        		var run = runs[0];
                                if('undefined' === typeof run.ea || run.ea === null) run.ea = '+mj-ea';
                                if('undefined' === typeof run.latin || run.latin === null) run.latin = '+mj-lt';
                                if('undefined' === typeof run.lang || run.lang === null) run.lang = 'zh-TW';
                                
                                if(run.ea !== '+mj-ea' && run.ea !== '+mn-ea') {
                                    var buFace = run.ea;
                                } else {
                                    var tmp = fontmap[run[langmap[run.lang]]];
                                    if(typeof tmp === 'string') {
                                        var buFace = tmp;
                                    } else {
                                        var buFace = tmp[scriptmap[run.lang]];
                                    }
                                }

                                switch(paragraph.buAutoNum) {
                                	case 'circleNumWdWhitePlain':
                                		if(linenum<11) {
                                			buChar = String.fromCharCode(0x2460 + linenum);
                                		} else {
                                			buChar = linenum;
                                		}
                                	break;
                                }

	                            buOffX = drawText(ctx, textOffX, textOffY, buFace, (!!run.solidFill?run.solidFill:'tx1'), !!run.sz?run.sz:1800, buChar + ' ');
	                            textOffX += buOffX;
                        	}
                        }
                        paragraph.runs.forEach(function(run) {
                            if(run.type === 'r' && !!run.text) {
                                if('undefined' === typeof run.ea || run.ea === null) run.ea = '+mj-ea';
                                if('undefined' === typeof run.latin || run.latin === null) run.latin = '+mj-lt';
                                if('undefined' === typeof run.lang || run.lang === null) run.lang = 'zh-TW';
                                
                                if(run.ea !== '+mj-ea' && run.ea !== '+mn-ea') {
                                    var face = run.ea;
                                } else {
                                    var tmp = fontmap[run[langmap[run.lang]]];
                                    if(typeof tmp === 'string') {
                                        var face = tmp;
                                    } else {
                                        var face = tmp[scriptmap[run.lang]];
                                    }
                                }

                                for(var i=0; i<run.text.length; i++) {
                                    textOffX += drawText(ctx, textOffX, textOffY, face, (!!run.solidFill?run.solidFill:'tx2'), !!run.sz?run.sz:1800, run.text[i], run.b, run.i);
                                }
                            }
                            if(run.type === 'br') {
                                textOffY += lineSpec[para_line_num].h;
                                para_line_num++;
                                switch(align) {
                                	case 'r':
                                	textOffX = shape.x + shape.cx - (!!paragraph.marR?paragraph.marR:0) - block.rIns - lineSpec[para_line_num].w;
                                	break;
                                	case 'ctr':
                                	textOffX = shape.x + shape.cx / 2 - lineSpec[para_line_num].w / 2;
                                	break;
                                	default:
	                                textOffX = x + (!!paragraph.marL?paragraph.marL:0) + (!!paragraph.indent?paragraph.indent:0) + buOffX;
                                	break;
                                }
                            }
                            if(run.type === 'end') {
                            	//console.log('run end');
                            }
                        });
                    }
                    textOffY += lineSpec[para_line_num].h;
                    linenum++;
                });

                function drawText(ctx, hpos, vpos, font, color, size, str, b, i) {
                	var localface = '';
                	if(!!b) localface += ' 900 ';
                	if(!!i) localface += ' italic ';
                	localface += pt2pixel(size, presentationData.cw, canvasData.cw) + 'px ' + font;
                    ctx.font = localface.trim();
                    var clr = color.indexOf('#') === 0 ? color : slide.colorScheme[slide.colorMap[color]];
                    ctx.fillStyle = clr;
                    //ctx.textBaseline = 'ideographic';
                    ctx.textBaseline = '';
                    ctx.fillText(str, emu2pixel(hpos), emu2pixel(vpos));
                    var ret = pixel2emu(ctx.measureText(str).width, presentationData.cw, canvasData.cw);
                    ctx.font = '';
                    ctx.fillStyle = '';
                    return ret;
                }
            }
        }

        function measureTextBlock(ctx, block, wrap) {
            if(typeof block.lIns === 'undefined') block.lIns = 91440;
            if(typeof block.tIns === 'undefined') block.tIns = 45720;
            if(typeof block.rIns === 'undefined') block.rIns = 91440;
            if(typeof block.bIns === 'undefined') block.bIns = 45720;
        	var tmp = block.paragraphs.reduce(function(pre, cur) {
        		var tmp = measureParagraph(ctx, cur, wrap);
        		pre.w += tmp.w;
        		pre.h += tmp.h;
        		return pre;
        	}, {w: 0, h: 0});
        	tmp.w += block.lIns + block.rIns;
        	tmp.h += block.tIns + block.bIns;
        	return tmp;
        }

        function measureBreakingParagraph(ctx, paragraph) {
        	var ret = {w: 0, h: 0};
    		var lh = paragraph.runs.reduce(function(pre, cur) {
    			if(cur.type === 'r' && cur.sz > pre) pre = cur.sz;
    			return pre;
    		}, 1800);
			var lineHeight = Math.round(pixel2emu(pt2pixel(lh, presentationData.cw, canvasData.cw) * 1.05));
    		ret.h = lineHeight;
    		var tmpwidth = [];
    		paragraph.runs.forEach(function(run) {
                if('undefined' === typeof run.ea || run.ea === null) run.ea = '+mj-ea';
                if('undefined' === typeof run.latin || run.latin === null) run.latin = '+mj-lt';
                if('undefined' === typeof run.lang || run.lang === null) run.lang = 'zh-TW';
                
                if(run.ea !== '+mj-ea' && run.ea !== '+mn-ea') {
                    var face = run.ea;
                } else {
                    var tmp = fontmap[run[langmap[run.lang]]];
                    if(typeof tmp === 'string') {
                        var face = tmp;
                    } else {
                        var face = tmp[scriptmap[run.lang]];
                    }
                }
    			if(run.type === 'br') {
    				tmpwidth.push(ret.w);
    				ret.w = 0;
    			}
    			if(run.type === 'r') {
    				if(!!run.text && run.text.length > 0) {
        				ret.w += measureText(ctx, run.text, face, !!run.sz?run.sz:1800, run.b, run.i);
    				}
    			}
    		});
			tmpwidth.push(ret.w);
			return tmpwidth.reduce(function(pre, cur) {
				pre.push({w: cur, h: ret.h});
				return pre;
			}, []);
        }

        function measureParagraph(ctx, paragraph, wrap) {
        	var ret = {w: 0, h: 0};
    		var lh = paragraph.runs.reduce(function(pre, cur) {
    			if(cur.type === 'r' && cur.sz > pre) pre = cur.sz;
    			return pre;
    		}, 1800);
    		var lineHeight = Math.round(pixel2emu(pt2pixel(lh, presentationData.cw, canvasData.cw) * 1.05, presentationData.cw, canvasData.cw));
        	if(wrap) {
        		ret.h = lineHeight;
        		var tmpwidth = [];
        		paragraph.runs.forEach(function(run) {
                    if('undefined' === typeof run.ea || run.ea === null) run.ea = '+mj-ea';
                    if('undefined' === typeof run.latin || run.latin === null) run.latin = '+mj-lt';
                    if('undefined' === typeof run.lang || run.lang === null) run.lang = 'zh-TW';
                    
                    if(run.ea !== '+mj-ea' && run.ea !== '+mn-ea') {
                        var face = run.ea;
                    } else {
                        var tmp = fontmap[run[langmap[run.lang]]];
                        if(typeof tmp === 'string') {
                            var face = tmp;
                        } else {
                            var face = tmp[scriptmap[run.lang]];
                        }
                    }
        			if(run.type === 'br') {
        				ret.h += lineHeight;
        				tmpwidth.push(ret.w);
        				ret.w = 0;
        			}
        			if(run.type === 'r') {
        				if(!!run.text && run.text.length > 0) {
            				ret.w += measureText(ctx, run.text, face, !!run.sz?run.sz:1800, run.b, run.i);
        				}
        			}
        		});
				if(tmpwidth.length > 0) {
					ret.w = tmpwidth[0];
				}
        	} else {
        		ret.h = lineHeight;
        		paragraph.runs.forEach(function(run) {
                    if('undefined' === typeof run.ea || run.ea === null) run.ea = '+mj-ea';
                    if('undefined' === typeof run.latin || run.latin === null) run.latin = '+mj-lt';
                    if('undefined' === typeof run.lang || run.lang === null) run.lang = 'zh-TW';
                    
                    if(run.ea !== '+mj-ea' && run.ea !== '+mn-ea') {
                        var face = run.ea;
                    } else {
                        var tmp = fontmap[run[langmap[run.lang]]];
                        if(typeof tmp === 'string') {
                            var face = tmp;
                        } else {
                            var face = tmp[scriptmap[run.lang]];
                        }
                    }
        			if(run.type === 'r') {
        				if(!!run.text && run.text.length > 0) {
            				ret.w += measureText(ctx, run.text, face, !!run.sz?run.sz:1800, run.b, run.i);
        				}
        			}
        		});
        	}
        	ret.w += (!!paragraph.marL?paragraph.marL:0) + (!!paragraph.marR?paragraph.marR:0);
			return ret;
        }

        function measureText(ctx, str, font, size, b, i) {
			var localface = '';
			var ret = 0;
        	if(!!b) localface += ' 900 ';
        	if(!!i) localface += ' italic ';
        	localface += pt2pixel(size, presentationData.cw, canvasData.cw) + 'px ' + font;
            ctx.font = localface.trim();
            var tmp = ctx.measureText(str).width;
            ret += pixel2emu(tmp, presentationData.cw, canvasData.cw);
            return ret;
        }

        function drawPic(pic) {
            var ctx = pic.canvas.getContext('2d');
            var img = media[pic.blip.embed];
        	if(typeof pic.blip.srcRect === 'undefined') pic.blip.srcRect = {l:0, r:0, t:0, b:0};
            var picx = img.width, picy = img.height;
            var l = pic.blip.srcRect.l / 100000, r = pic.blip.srcRect.r / 100000, t = pic.blip.srcRect.t / 100000, b = pic.blip.srcRect.b / 100000;
            var offx = pic.x, offy = pic.y;
            var cx = pic.cx, cy = pic.cy;

            var sx = Math.round(picx * l), sy = Math.round(picy * t);
            var sw = Math.round(picx - picx * (l + r)), sh = Math.round(picy - picy * (t + b));
            var dx = emu2pixel(offx), dy = emu2pixel(offy);
            var dw = emu2pixel(cx), dh = emu2pixel(cy);
            ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
            //pic.canvas.className = 'steps_canvas';
        }

        /*function drawTransition(transition, target, next, mask) {
            var start = null;
            requestAnimationFrame(transitionAnimate);
            function transitionAnimate(t) {
                if (start === null) {
                    start = t;
                    requestAnimationFrame(transitionAnimate);
                } else {
                    var progress = (t - start) / transition.duration;
                    mask.fillStyle = '#FFFFFF';
                    mask.fillRect(0, 0, canvasData.canvas.width, canvasData.canvas.height);
                    drawTransitionPattern(transition, mask, progress);
                    var x = 0, y = 0;
                    var maskImg = mask.getImageData(0, 0, canvasData.cw, canvasData.ch);
                    var nextImg = next.getImageData(0, 0, canvasData.cw, canvasData.ch);
                    var targetImg = target.getImageData(0, 0, canvasData.cw, canvasData.ch);
                    var output = target.createImageData(targetImg);
                    for (var i = 0; i < targetImg.data.length; i += 4) {
                        if (maskImg.data[i] == 0 && maskImg.data[i + 1] == 0 && maskImg.data[i + 2] == 0) {
                            output.data[i] = nextImg.data[i];
                            output.data[i + 1] = nextImg.data[i + 1];
                            output.data[i + 2] = nextImg.data[i + 2];
                            output.data[i + 3] = 255;
                        } else {
                            output.data[i] = targetImg.data[i];
                            output.data[i + 1] = targetImg.data[i + 1];
                            output.data[i + 2] = targetImg.data[i + 2];
                            output.data[i + 3] = 255;
                        }
                    }
                    target.putImageData(output, 0, 0);
                    if (t - start < transition.duration) {
                        requestAnimationFrame(transitionAnimate);
                    }
                }
            }
        }*/

        /*function drawTransitionPattern(transition, mask, progress) {
            switch (transition.type) {
                case 'comb':
                    var num = 8;
                    var start = 0;
                    var side = 0;
                    if (transition.dir === 'horz') {
                        var bh = Math.round(canvasData.ch / num);
                        while (start < canvasData.ch) {
                            mask.fillStyle = '#000000';
                            if (side % 2 === 0) {
                                mask.fillRect(0, start, Math.round(progress * canvasData.cw), bh);
                            } else {
                                var l = Math.round(canvasData.cw * (1 - progress));
                                mask.fillRect(Math.round(canvasData.cw * (1 - progress)), start, canvasData.cw - l, bh);
                            }
                            start += bh;
                            side++;
                        }
                    } else {
                        var bw = Math.round(canvasData.cw / num);
                        while (start < canvasData.cw) {
                            mask.fillStyle = '#000000';
                            if (side % 2 === 0) {
                                mask.fillRect(start, 0, bw, Math.round(progress * canvasData.ch));
                            } else {
                                var t = Math.round(canvasData.ch * (1 - progress));
                                mask.fillRect(start, Math.round(canvasData.ch * (1 - progress)), bw, canvasData.ch - t);
                            }
                            start += bw;
                            side++;
                        }
                    }
                    break;
            }
        }*/

        function pt2pixel(sz) {
        	var screenw = presentationData.cw, canvasw = canvasData.cw;
            return sz * 914400 * canvasw / 100 / 72 / screenw;
        }

        function emu2pixel(l) {
        	var screenw = presentationData.cw, canvasw = canvasData.cw;
            return l * canvasw / screenw;
        }

        function pixel2emu(l) {
        	var screenw = presentationData.cw, canvasw = canvasData.cw;
            return l * screenw / canvasw;
        }

        function calculateCanvasWidth(vzw, vzh) {
            if (vzh / 3 * 4 < vzw) {
                return {w: Math.round((vzh - 20) * 4 / 3), h: vzh - 20};
            } else {
                return {w: vzw - Math.round(20 * 4 / 3), h: Math.round(vzw * 3 / 4) - 20};
            }
        }

        function define_quadratic_bezier(x0, y0, x1, y1, x2, y2) {
            return function (t) {
                if (t < 0 || t > 1) throw new Error('[define_quadratic_bezier] t must between 0 and 1.');
                var px = Math.pow(1 - t, 2) * x0 + 2 * t * (1 - t) * x1 + Math.pow(t, 2) * x2;
                var py = Math.pow(1 - t, 2) * y0 + 2 * t * (1 - t) * y1 + Math.pow(t, 2) * y2;
                return [px, py];
            };
        }

        //this easing is from jquery's swing
        function easing(p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        }
        
        function wait(f, n) {
        	var count = f.length;
        	f.forEach(function(g) {
        		g(done);
        	});
        	function done() {
        		count--;
        		if(count <= 0) {
        			n();
        		}
        	}
        }

        function shade(color, fact) {
        	color = color.trim();
        	fact = fact / 100000;
        	if(color.indexOf('#') === 0) {
        		var c = color.substr(1);
        	} else {
        		var c = color;
        	}
    		var r = parseInt(c.substr(0, 2), 16);
    		var g = parseInt(c.substr(2, 2), 16);
    		var b = parseInt(c.substr(4, 2), 16);
    		r = Math.round(r * (1 - fact<1?fact:fact/100000));
    		g = Math.round(g * (1 - fact<1?fact:fact/100000));
    		b = Math.round(b * (1 - fact<1?fact:fact/100000));
    		return '#' + padHex(r, 2).toUpperCase() + padHex(g, 2).toUpperCase() + padHex(b, 2).toUpperCase();
        }

        function tint(color, fact) {
        	color = color.trim();
        	if(color.indexOf('#') === 0) {
        		var c = color.substr(1);
        	} else {
        		var c = color;
        	}
    		var r = parseInt(c.substr(0, 2), 16);
    		var g = parseInt(c.substr(2, 2), 16);
    		var b = parseInt(c.substr(4, 2), 16);
    		r = Math.round(r + (255 - r) * fact<1?fact:fact/100000);
    		g = Math.round(g + (255 - g) * fact<1?fact:fact/100000);
    		b = Math.round(b + (255 - b) * fact<1?fact:fact/100000);
    		return '#' + padHex(r, 2).toUpperCase() + padHex(g, 2).toUpperCase() + padHex(b, 2).toUpperCase();
        }

        function padHex(input, l) {
        	if(typeof input !== 'string') {
        		input = input.toString(16);
        	}
        	var ret = input;
        	for(var i=0; i<l-input.length; i++) {
        		ret = '0' + ret;
        	}
        	return ret;
        }

        function stepExecuter(step) {
            anim_lock = true;
            executers.shapes = data.slides[slideList[currentSlide].rid].commonSlideData.shapes;
            executers.queues = {length:0, delay:[], duration:[], action:[]};
            executers.actions = 0;
            executers.orig = [];
            executers.last = null;
            stepParser(step);
            if(!!executers.last && executers.last.name === 'p:set') {
                var t = executers.shapes.filter(function(x) {return parseInt(x.id, 10) === parseInt(executers.last.tgtEl, 10)});
                if(t.length > 0) {
                    clearCanvas(t[0].canvas);
                    drawShape(t[0]);
                    render(data.slides[slideList[currentSlide].rid], canvas);
                    anim_lock = false;
                }
            }
        }

        var executers = {
            'p:par': function(node) {
                anim_lock = true;
                var self = this;
                if(!!node.stCondLst) {
                    node.stCondLst.forEach(function(cond) {
                        if(!isNaN(parseInt(cond.delay, 10))) {
                            if(node.nodeType === 'withGroup' || node.nodeType === 'afterGroup') {
                                self.queues.delay.push(cond.delay);
                            }
                        }
                    })
                }
            },
            'p:seq': function(node) {
                anim_lock = true;
            },
            'p:set': function(node) {
                anim_lock = true;
                var t = this.shapes.filter(function(s) {
                    return !!s.id && !!node.tgtEl && parseInt(s.id, 10) === parseInt(node.tgtEl, 10);
                });
                if(t.length > 0) {
                    var target = t[0];
                    if(!!node.attrNameLst) {
                        node.attrNameLst.forEach(function(a) {
                            var t1 = a.val;
                            var t2 = t1.split('.');
                            for(var i=0; i< t2.length-1; i++) {
                                target = target[t2[i]];
                            }
                            target[t2[t2.length-1]] = node.to;
                            if(!!t[0].orig) {
                                t[0].orig.style = {visibility: 'invisible'};
                            } else {
                                t[0].orig = {style: {visibility: 'invisible'}};
                            }
                        })
                    }
                }
            },
            'p:anim': function(node) {
                anim_lock = true;
                var spid = node.tgtEl;
                var shape = data.slides[slideList[currentSlide].rid].commonSlideData.shapes.filter(function(x) {return parseInt(x.id, 10) === parseInt(spid, 10)})[0];
                clearCanvas(shape.canvas);
                drawShape(shape);
                render(data.slides[slideList[currentSlide].rid], canvas);
                executers.actions++;
                anim_lock = false;
            },
            'p:animScale': function(node) {
                anim_lock = true;
                var self = this;
                var spid = node.tgtEl;
                var shape = data.slides[slideList[currentSlide].rid].commonSlideData.shapes.filter(function(x) {return parseInt(x.id, 10) === parseInt(spid, 10)})[0];
                if(!!shape.orig) {
                    shape.orig.x = shape.x;
                    shape.orig.y = shape.y;
                    shape.orig.cx = shape.cx;
                    shape.orig.cy = shape.cy;
                    shape.orig.textBody = clone(shape.textBody);
                } else {
                    shape.orig = {x: shape.x, y: shape.y, cx: shape.cx, cy: shape.cy, textBody: clone(shape.textBody)};
                }
                this.queues.duration.push(node.dur);
                var duration = parseInt(node.dur, 10);
                var ctrx = shape.x + shape.cx / 2;
                var ctry = shape.y + shape.cy / 2;
                var mid = duration / 2;
                var ratex = node.by.x / 100000;
                var ratey = node.by.y / 100000;
                var start = null;
                setTimeout(function() {
                    anim_lock = true;
                    requestAnimationFrame(animScale);
                }, executers.queues.delay[executers.actions]);
                executers.actions++;
                function animScale(ts) {
                    anim_lock = true;
                    if(start === null) {
                        start = ts;
                        var now = 0;
                    } else {
                        var now = ts - start;
                    }
                    if(now < duration) {
                        if(now < mid) {
                            var ratecx = (1 + (now / mid * (ratex-1))) * shape.orig.cx;
                            var ratecy = (1 + (now / mid * (ratey-1))) * shape.orig.cy;
                            var nowx = ctrx - ratecx / 2;
                            var nowy = ctry - ratecy / 2;
                            var ratesz = (1 + (now / mid * (ratex-1)));
                            shape.textBody.paragraphs.forEach(function(p, idxp) {
                                p.runs.forEach(function(r, idxr) {
                                    r.sz = Math.round(parseInt(shape.orig.textBody.paragraphs[idxp].runs[idxr].sz, 10) * ratesz);
                                });
                            });
                        } else {
                            var ratecx = (1 + (1 - (now - mid) / mid) * (ratex-1)) * shape.orig.cx;
                            var ratecy = (1 + (1 - (now - mid) / mid) * (ratey-1)) * shape.orig.cy;
                            var nowx = ctrx - ratecx / 2;
                            var nowy = ctry - ratecy / 2;
                            var ratesz = (1 + (1 - (now - mid) / mid) * (ratex-1));
                            shape.textBody.paragraphs.forEach(function(p, idxp) {
                                p.runs.forEach(function(r, idxr) {
                                    r.sz = Math.round(parseInt(shape.orig.textBody.paragraphs[idxp].runs[idxr].sz, 10) * ratesz);
                                });
                            });
                        }
                        shape.x = nowx;
                        shape.y = nowy;
                        shape.cx = ratecx;
                        shape.cy = ratecy;
                        clearCanvas(shape.canvas);
                        drawShape(shape);
                        render(data.slides[slideList[currentSlide].rid], canvas);
                        requestAnimationFrame(animScale);
                    } else {
                        /*self.orig.forEach(function(o) {
                            if(o.id === shape.id) {
                                Object.keys(o).forEach(function(p) {
                                    if(p !== 'id') {
                                        shape[p] = o[p];
                                    }
                                });
                            }
                        });*/
                        clearCanvas(shape.canvas);
                        drawShape(shape);
                        render(data.slides[slideList[currentSlide].rid], canvas);
                        anim_lock = false;
                    }
                }
            },
            'p:animMotion': function(node) {
                anim_lock = true;
                var spid = node.tgtEl;
                var shape = data.slides[slideList[currentSlide].rid].commonSlideData.shapes.filter(function(x) {return parseInt(x.id, 10) === parseInt(spid, 10)})[0];
                if(!!shape.orig) {
                    shape.orig.x = shape.x;
                    shape.orig.y = shape.y;
                } else {
                    shape.orig = {x: shape.x, y: shape.y};
                }

                var a = node.path.trim().split(' ');
                var ax = a[a.length-2] * data.presentation.slideSize.cx;
                var ay = a[a.length-1] * data.presentation.slideSize.cy;
                var start = null;
                var duration = node.dur;
                setTimeout(function() {
                    anim_lock = true;
                    requestAnimationFrame(animMotion);
                }, executers.queues.delay[executers.actions]);
                executers.actions++;
                function animMotion(ts) {
                    if(!!start) {
                        var now = ts - start;
                    } else {
                        start = ts;
                        var now = 0;
                    }
                    if(now < duration) {
                        shape.x = shape.orig.x + now / duration * ax;
                        shape.y = shape.orig.y + now / duration * ay;
                        clearCanvas(shape.canvas);
                        drawShape(shape);
                        render(data.slides[slideList[currentSlide].rid], canvas);
                        requestAnimationFrame(animMotion);
                    } else {
                        shape.x = shape.orig.x + ax;
                        shape.y = shape.orig.y + ay;
                        clearCanvas(shape.canvas);
                        drawShape(shape);
                        render(data.slides[slideList[currentSlide].rid], canvas);
                        /*shape.x = orig.x;
                        shape.y = orig.y;*/
                        anim_lock = false;
                    }
                }
            },
            'p:animEffect': function(node) {
                anim_lock = true;
                var adj = 914400/15;
                var transitions = {
                    'in': {
                        'slide(fromLeft)': function(ts) {
                            anim_lock = true;
                            if(!!start) {
                                var now = ts - start;
                            } else {
                                start = ts;
                                var now = 0;
                            }
                            if(now < duration) {
                                shape.x = shape.orig.x - shape.cx + now / duration * shape.cx;
                                clearCanvas(shape.canvas);
                                drawShape(shape);
                                render(data.slides[slideList[currentSlide].rid], canvas);
                                requestAnimationFrame(transitions[node.transition][node.filter]);
                            } else {
                                shape.x = shape.orig.x;
                                clearCanvas(shape.canvas);
                                drawShape(shape);
                                render(data.slides[slideList[currentSlide].rid], canvas);
                                anim_lock = false;
                            }
                        },
                        'slide(fromRight)': function(ts) {
                            anim_lock = true;
                            if(!!start) {
                                var now = ts - start;
                            } else {
                                start = ts;
                                var now = 0;
                            }
                            if(now < duration) {
                                shape.x = shape.orig.x + shape.cx - now / duration * shape.cx;
                                clearCanvas(shape.canvas);
                                drawShape(shape);
                                render(data.slides[slideList[currentSlide].rid], canvas);
                                requestAnimationFrame(transitions[node.transition][node.filter]);
                            } else {
                                shape.x = shape.orig.x;
                                clearCanvas(shape.canvas);
                                drawShape(shape);
                                render(data.slides[slideList[currentSlide].rid], canvas);
                                anim_lock = false;
                            }
                        },
                        'slide(fromTop)': function(ts) {
                            anim_lock = true;
                            if(!!start) {
                                var now = ts - start;
                            } else {
                                start = ts;
                                var now = 0;
                            }
                            if(now < duration) {
                                shape.y = shape.orig.y - shape.cy + now / duration * shape.cy;
                                clearCanvas(shape.canvas);
                                drawShape(shape);
                                render(data.slides[slideList[currentSlide].rid], canvas);
                                requestAnimationFrame(transitions[node.transition][node.filter]);
                            } else {
                                shape.y = shape.orig.y;
                                clearCanvas(shape.canvas);
                                drawShape(shape);
                                render(data.slides[slideList[currentSlide].rid], canvas);
                                anim_lock = false;
                            }
                        },
                        'slide(fromBottom)': function(ts) {
                            anim_lock = true;
                            if(!!start) {
                                var now = ts - start;
                            } else {
                                start = ts;
                                var now = 0;
                            }
                            if(now < duration) {
                                shape.y = shape.orig.y + shape.cy - now / duration * shape.cy;
                                clearCanvas(shape.canvas);
                                drawShape(shape);
                                render(data.slides[slideList[currentSlide].rid], canvas);
                                requestAnimationFrame(transitions[node.transition][node.filter]);
                            } else {
                                shape.y = shape.orig.y;
                                clearCanvas(shape.canvas);
                                drawShape(shape);
                                render(data.slides[slideList[currentSlide].rid], canvas);
                                anim_lock = false;
                            }
                        },
                        'fade': function(ts) {
                            anim_lock = true;
                            if(!!start) {
                                var now = ts - start;
                            } else {
                                start = ts;
                                var now = 0;
                            }
                            if(now < duration) {
                                shape.canvas.getContext('2d').globalAlpha = 0;
                                clearCanvas(shape.canvas);
                                shape.canvas.getContext('2d').globalAlpha = now / duration;
                                drawShape(shape);
                                render(data.slides[slideList[currentSlide].rid], canvas);
                                requestAnimationFrame(transitions[node.transition][node.filter]);
                            } else {
                                shape.x = shape.orig.x;
                                shape.y = shape.orig.y;
                                shape.canvas.getContext('2d').globalAlpha = 0;
                                clearCanvas(shape.canvas);
                                shape.canvas.getContext('2d').globalAlpha = 1;
                                drawShape(shape);
                                render(data.slides[slideList[currentSlide].rid], canvas);
                                anim_lock = false;
                            }
                        }
                    }
                };

                var spid = node.tgtEl;
                var shape = data.slides[slideList[currentSlide].rid].commonSlideData.shapes.filter(function(x) {return parseInt(x.id, 10) === parseInt(spid, 10)})[0];
                if(!!shape.orig) {
                    shape.orig.x = shape.x;
                    shape.orig.y = shape.y;
                } else {
                    shape.orig = {x: shape.x, y: shape.y};
                }
                if(!transitions[node.transition] || (!!transitions[node.transition] && !transitions[node.transition][node.filter])) {
                    throw new Error('Specified transition or filter not supported:[' + node.transition + ',' + node.filter + ']');
                }
                var duration = node.dur;
                var start = null;
                setTimeout(function() {
                    anim_lock = true;
                    requestAnimationFrame(transitions[node.transition][node.filter]);
                }, executers.queues.delay[executers.actions]);
                executers.actions++;
            }
        };

        function stepParser(node) {
            if(!!executers[node.name]) {
                executers[node.name](node);
                executers.last = node;
            } else {
                throw new Error('executer for ' + node.name + ' not found.');
            }
            if(!!node.childTnLst) {
                node.childTnLst.forEach(function(child) {
                    stepParser(child);
                });
            }
        }

        function createCanvas(slide) {
            var ret = document.createElement('canvas');
            ret.width = canvasData.cw;
            ret.height = canvasData.ch;
            ret.className = 'steps_canvas_hidden';
            if(!!slide) {
                ret.style.backgroundColor = 'white';
            }
            document.getElementById('panel').appendChild(ret);
            return ret;
        }

        function clearCanvas(canvas) {
            var ctx = canvas.getContext('2d');
            var d = ctx.createImageData(canvasData.cw, canvasData.ch);
            ctx.putImageData(d, 0, 0);
            d = null;
        }

        function removeTempCanvas(canvas) {
            document.getElementById('panel').removeChild(canvas);
        }

        function render(slide, to) {
            var ctx2 = buffer.getContext('2d');
            slide.commonSlideData.shapes.forEach(function(shape) {
                if(!!shape.style && !!shape.style.visibility && shape.style.visibility === 'invisible') {
                } else {
                    ctx2.drawImage(shape.canvas, 0, 0, canvasData.cw, canvasData.ch);
                }
            });
            var im = buffer.getContext('2d').getImageData(0, 0, canvasData.cw, canvasData.ch);
            to.getContext('2d').putImageData(im, 0, 0);
            //stepsCanvas[currentStep] = im;
        }

        //from http://stackoverflow.com/questions/728360/how-do-i-correctly-clone-a-javascript-object
        function clone(obj) {
            var copy;
            if(null == obj || "object" !== typeof obj) return obj;
            if(obj instanceof Date) {
                copy = new Date();
                copy.setTime(obj.getTime());
                return copy;
            }
            if(Array.isArray(obj)) {
                copy = [];
                obj.forEach(function(a, i) {
                    copy[i] = clone(a);
                });
                return copy;
            }
            if(obj instanceof Object) {
                copy = {};
                Object.keys(obj).forEach(function(p) {
                    copy[p] = clone(obj[p]);
                });
                return copy;
            }
            throw new Error("Unable to copy obj! Its type isn't supported.");
        }
    });
</script>
</body>
</html>
